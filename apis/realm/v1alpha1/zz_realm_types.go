/*
Copyright 2022 Upbound Inc.
*/

// Code generated by upjet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type AuthObservation struct {
}

type AuthParameters struct {

	// +kubebuilder:validation:Required
	PasswordSecretRef v1.SecretKeySelector `json:"passwordSecretRef" tf:"-"`

	// +kubebuilder:validation:Required
	Username *string `json:"username" tf:"username,omitempty"`
}

type BruteForceDetectionObservation struct {
}

type BruteForceDetectionParameters struct {

	// +kubebuilder:validation:Optional
	FailureResetTimeSeconds *float64 `json:"failureResetTimeSeconds,omitempty" tf:"failure_reset_time_seconds,omitempty"`

	// +kubebuilder:validation:Optional
	MaxFailureWaitSeconds *float64 `json:"maxFailureWaitSeconds,omitempty" tf:"max_failure_wait_seconds,omitempty"`

	// +kubebuilder:validation:Optional
	MaxLoginFailures *float64 `json:"maxLoginFailures,omitempty" tf:"max_login_failures,omitempty"`

	// +kubebuilder:validation:Optional
	MinimumQuickLoginWaitSeconds *float64 `json:"minimumQuickLoginWaitSeconds,omitempty" tf:"minimum_quick_login_wait_seconds,omitempty"`

	// +kubebuilder:validation:Optional
	PermanentLockout *bool `json:"permanentLockout,omitempty" tf:"permanent_lockout,omitempty"`

	// +kubebuilder:validation:Optional
	QuickLoginCheckMilliSeconds *float64 `json:"quickLoginCheckMilliSeconds,omitempty" tf:"quick_login_check_milli_seconds,omitempty"`

	// +kubebuilder:validation:Optional
	WaitIncrementSeconds *float64 `json:"waitIncrementSeconds,omitempty" tf:"wait_increment_seconds,omitempty"`
}

type HeadersObservation struct {
}

type HeadersParameters struct {

	// +kubebuilder:validation:Optional
	ContentSecurityPolicy *string `json:"contentSecurityPolicy,omitempty" tf:"content_security_policy,omitempty"`

	// +kubebuilder:validation:Optional
	ContentSecurityPolicyReportOnly *string `json:"contentSecurityPolicyReportOnly,omitempty" tf:"content_security_policy_report_only,omitempty"`

	// +kubebuilder:validation:Optional
	StrictTransportSecurity *string `json:"strictTransportSecurity,omitempty" tf:"strict_transport_security,omitempty"`

	// +kubebuilder:validation:Optional
	XContentTypeOptions *string `json:"xContentTypeOptions,omitempty" tf:"x_content_type_options,omitempty"`

	// +kubebuilder:validation:Optional
	XFrameOptions *string `json:"xFrameOptions,omitempty" tf:"x_frame_options,omitempty"`

	// +kubebuilder:validation:Optional
	XRobotsTag *string `json:"xRobotsTag,omitempty" tf:"x_robots_tag,omitempty"`

	// +kubebuilder:validation:Optional
	XXSSProtection *string `json:"xXssProtection,omitempty" tf:"x_xss_protection,omitempty"`
}

type InternationalizationObservation struct {
}

type InternationalizationParameters struct {

	// +kubebuilder:validation:Required
	DefaultLocale *string `json:"defaultLocale" tf:"default_locale,omitempty"`

	// +kubebuilder:validation:Required
	SupportedLocales []*string `json:"supportedLocales" tf:"supported_locales,omitempty"`
}

type OtpPolicyObservation struct {
}

type OtpPolicyParameters struct {

	// What hashing algorithm should be used to generate the OTP.
	// +kubebuilder:validation:Optional
	Algorithm *string `json:"algorithm,omitempty" tf:"algorithm,omitempty"`

	// +kubebuilder:validation:Optional
	Digits *float64 `json:"digits,omitempty" tf:"digits,omitempty"`

	// +kubebuilder:validation:Optional
	InitialCounter *float64 `json:"initialCounter,omitempty" tf:"initial_counter,omitempty"`

	// +kubebuilder:validation:Optional
	LookAheadWindow *float64 `json:"lookAheadWindow,omitempty" tf:"look_ahead_window,omitempty"`

	// +kubebuilder:validation:Optional
	Period *float64 `json:"period,omitempty" tf:"period,omitempty"`

	// OTP Type, totp for Time-Based One Time Password or hotp for counter base one time password
	// +kubebuilder:validation:Optional
	Type *string `json:"type,omitempty" tf:"type,omitempty"`
}

type RealmObservation struct {
	ID *string `json:"id,omitempty" tf:"id,omitempty"`
}

type RealmParameters struct {

	// +kubebuilder:validation:Optional
	AccessCodeLifespan *string `json:"accessCodeLifespan,omitempty" tf:"access_code_lifespan,omitempty"`

	// +kubebuilder:validation:Optional
	AccessCodeLifespanLogin *string `json:"accessCodeLifespanLogin,omitempty" tf:"access_code_lifespan_login,omitempty"`

	// +kubebuilder:validation:Optional
	AccessCodeLifespanUserAction *string `json:"accessCodeLifespanUserAction,omitempty" tf:"access_code_lifespan_user_action,omitempty"`

	// +kubebuilder:validation:Optional
	AccessTokenLifespan *string `json:"accessTokenLifespan,omitempty" tf:"access_token_lifespan,omitempty"`

	// +kubebuilder:validation:Optional
	AccessTokenLifespanForImplicitFlow *string `json:"accessTokenLifespanForImplicitFlow,omitempty" tf:"access_token_lifespan_for_implicit_flow,omitempty"`

	// +kubebuilder:validation:Optional
	AccountTheme *string `json:"accountTheme,omitempty" tf:"account_theme,omitempty"`

	// +kubebuilder:validation:Optional
	ActionTokenGeneratedByAdminLifespan *string `json:"actionTokenGeneratedByAdminLifespan,omitempty" tf:"action_token_generated_by_admin_lifespan,omitempty"`

	// +kubebuilder:validation:Optional
	ActionTokenGeneratedByUserLifespan *string `json:"actionTokenGeneratedByUserLifespan,omitempty" tf:"action_token_generated_by_user_lifespan,omitempty"`

	// +kubebuilder:validation:Optional
	AdminTheme *string `json:"adminTheme,omitempty" tf:"admin_theme,omitempty"`

	// +kubebuilder:validation:Optional
	Attributes map[string]*string `json:"attributes,omitempty" tf:"attributes,omitempty"`

	// Which flow should be used for BrowserFlow
	// +kubebuilder:validation:Optional
	BrowserFlow *string `json:"browserFlow,omitempty" tf:"browser_flow,omitempty"`

	// Which flow should be used for ClientAuthenticationFlow
	// +kubebuilder:validation:Optional
	ClientAuthenticationFlow *string `json:"clientAuthenticationFlow,omitempty" tf:"client_authentication_flow,omitempty"`

	// +kubebuilder:validation:Optional
	ClientSessionIdleTimeout *string `json:"clientSessionIdleTimeout,omitempty" tf:"client_session_idle_timeout,omitempty"`

	// +kubebuilder:validation:Optional
	ClientSessionMaxLifespan *string `json:"clientSessionMaxLifespan,omitempty" tf:"client_session_max_lifespan,omitempty"`

	// +kubebuilder:validation:Optional
	DefaultDefaultClientScopes []*string `json:"defaultDefaultClientScopes,omitempty" tf:"default_default_client_scopes,omitempty"`

	// +kubebuilder:validation:Optional
	DefaultOptionalClientScopes []*string `json:"defaultOptionalClientScopes,omitempty" tf:"default_optional_client_scopes,omitempty"`

	// +kubebuilder:validation:Optional
	DefaultSignatureAlgorithm *string `json:"defaultSignatureAlgorithm,omitempty" tf:"default_signature_algorithm,omitempty"`

	// Which flow should be used for DirectGrantFlow
	// +kubebuilder:validation:Optional
	DirectGrantFlow *string `json:"directGrantFlow,omitempty" tf:"direct_grant_flow,omitempty"`

	// +kubebuilder:validation:Optional
	DisplayName *string `json:"displayName,omitempty" tf:"display_name,omitempty"`

	// +kubebuilder:validation:Optional
	DisplayNameHTML *string `json:"displayNameHtml,omitempty" tf:"display_name_html,omitempty"`

	// Which flow should be used for DockerAuthenticationFlow
	// +kubebuilder:validation:Optional
	DockerAuthenticationFlow *string `json:"dockerAuthenticationFlow,omitempty" tf:"docker_authentication_flow,omitempty"`

	// +kubebuilder:validation:Optional
	DuplicateEmailsAllowed *bool `json:"duplicateEmailsAllowed,omitempty" tf:"duplicate_emails_allowed,omitempty"`

	// +kubebuilder:validation:Optional
	EditUsernameAllowed *bool `json:"editUsernameAllowed,omitempty" tf:"edit_username_allowed,omitempty"`

	// +kubebuilder:validation:Optional
	EmailTheme *string `json:"emailTheme,omitempty" tf:"email_theme,omitempty"`

	// +kubebuilder:validation:Optional
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`

	// +kubebuilder:validation:Optional
	InternalID *string `json:"internalId,omitempty" tf:"internal_id,omitempty"`

	// +kubebuilder:validation:Optional
	Internationalization []InternationalizationParameters `json:"internationalization,omitempty" tf:"internationalization,omitempty"`

	// +kubebuilder:validation:Optional
	LoginTheme *string `json:"loginTheme,omitempty" tf:"login_theme,omitempty"`

	// +kubebuilder:validation:Optional
	LoginWithEmailAllowed *bool `json:"loginWithEmailAllowed,omitempty" tf:"login_with_email_allowed,omitempty"`

	// +kubebuilder:validation:Optional
	Oauth2DeviceCodeLifespan *string `json:"oauth2DeviceCodeLifespan,omitempty" tf:"oauth2_device_code_lifespan,omitempty"`

	// +kubebuilder:validation:Optional
	Oauth2DevicePollingInterval *float64 `json:"oauth2DevicePollingInterval,omitempty" tf:"oauth2_device_polling_interval,omitempty"`

	// +kubebuilder:validation:Optional
	OfflineSessionIdleTimeout *string `json:"offlineSessionIdleTimeout,omitempty" tf:"offline_session_idle_timeout,omitempty"`

	// +kubebuilder:validation:Optional
	OfflineSessionMaxLifespan *string `json:"offlineSessionMaxLifespan,omitempty" tf:"offline_session_max_lifespan,omitempty"`

	// +kubebuilder:validation:Optional
	OfflineSessionMaxLifespanEnabled *bool `json:"offlineSessionMaxLifespanEnabled,omitempty" tf:"offline_session_max_lifespan_enabled,omitempty"`

	// +kubebuilder:validation:Optional
	OtpPolicy []OtpPolicyParameters `json:"otpPolicy,omitempty" tf:"otp_policy,omitempty"`

	// String that represents the passwordPolicies that are in place. Each policy is separated with " and ". Supported policies can be found in the server-info providers page. example: "upperCase(1) and length(8) and forceExpiredPasswordChange(365) and notUsername(undefined)"
	// +kubebuilder:validation:Optional
	PasswordPolicy *string `json:"passwordPolicy,omitempty" tf:"password_policy,omitempty"`

	// +kubebuilder:validation:Required
	Realm *string `json:"realm" tf:"realm,omitempty"`

	// +kubebuilder:validation:Optional
	RefreshTokenMaxReuse *float64 `json:"refreshTokenMaxReuse,omitempty" tf:"refresh_token_max_reuse,omitempty"`

	// +kubebuilder:validation:Optional
	RegistrationAllowed *bool `json:"registrationAllowed,omitempty" tf:"registration_allowed,omitempty"`

	// +kubebuilder:validation:Optional
	RegistrationEmailAsUsername *bool `json:"registrationEmailAsUsername,omitempty" tf:"registration_email_as_username,omitempty"`

	// Which flow should be used for RegistrationFlow
	// +kubebuilder:validation:Optional
	RegistrationFlow *string `json:"registrationFlow,omitempty" tf:"registration_flow,omitempty"`

	// +kubebuilder:validation:Optional
	RememberMe *bool `json:"rememberMe,omitempty" tf:"remember_me,omitempty"`

	// Which flow should be used for ResetCredentialsFlow
	// +kubebuilder:validation:Optional
	ResetCredentialsFlow *string `json:"resetCredentialsFlow,omitempty" tf:"reset_credentials_flow,omitempty"`

	// +kubebuilder:validation:Optional
	ResetPasswordAllowed *bool `json:"resetPasswordAllowed,omitempty" tf:"reset_password_allowed,omitempty"`

	// +kubebuilder:validation:Optional
	RevokeRefreshToken *bool `json:"revokeRefreshToken,omitempty" tf:"revoke_refresh_token,omitempty"`

	// +kubebuilder:validation:Optional
	SMTPServer []SMTPServerParameters `json:"smtpServer,omitempty" tf:"smtp_server,omitempty"`

	// SSL Required: Values can be 'none', 'external' or 'all'.
	// +kubebuilder:validation:Optional
	SSLRequired *string `json:"sslRequired,omitempty" tf:"ssl_required,omitempty"`

	// +kubebuilder:validation:Optional
	SecurityDefenses []SecurityDefensesParameters `json:"securityDefenses,omitempty" tf:"security_defenses,omitempty"`

	// +kubebuilder:validation:Optional
	SsoSessionIdleTimeout *string `json:"ssoSessionIdleTimeout,omitempty" tf:"sso_session_idle_timeout,omitempty"`

	// +kubebuilder:validation:Optional
	SsoSessionIdleTimeoutRememberMe *string `json:"ssoSessionIdleTimeoutRememberMe,omitempty" tf:"sso_session_idle_timeout_remember_me,omitempty"`

	// +kubebuilder:validation:Optional
	SsoSessionMaxLifespan *string `json:"ssoSessionMaxLifespan,omitempty" tf:"sso_session_max_lifespan,omitempty"`

	// +kubebuilder:validation:Optional
	SsoSessionMaxLifespanRememberMe *string `json:"ssoSessionMaxLifespanRememberMe,omitempty" tf:"sso_session_max_lifespan_remember_me,omitempty"`

	// +kubebuilder:validation:Optional
	UserManagedAccess *bool `json:"userManagedAccess,omitempty" tf:"user_managed_access,omitempty"`

	// +kubebuilder:validation:Optional
	VerifyEmail *bool `json:"verifyEmail,omitempty" tf:"verify_email,omitempty"`

	// +kubebuilder:validation:Optional
	WebAuthnPasswordlessPolicy []WebAuthnPasswordlessPolicyParameters `json:"webAuthnPasswordlessPolicy,omitempty" tf:"web_authn_passwordless_policy,omitempty"`

	// +kubebuilder:validation:Optional
	WebAuthnPolicy []WebAuthnPolicyParameters `json:"webAuthnPolicy,omitempty" tf:"web_authn_policy,omitempty"`
}

type SMTPServerObservation struct {
}

type SMTPServerParameters struct {

	// +kubebuilder:validation:Optional
	Auth []AuthParameters `json:"auth,omitempty" tf:"auth,omitempty"`

	// +kubebuilder:validation:Optional
	EnvelopeFrom *string `json:"envelopeFrom,omitempty" tf:"envelope_from,omitempty"`

	// +kubebuilder:validation:Required
	From *string `json:"from" tf:"from,omitempty"`

	// +kubebuilder:validation:Optional
	FromDisplayName *string `json:"fromDisplayName,omitempty" tf:"from_display_name,omitempty"`

	// +kubebuilder:validation:Required
	Host *string `json:"host" tf:"host,omitempty"`

	// +kubebuilder:validation:Optional
	Port *string `json:"port,omitempty" tf:"port,omitempty"`

	// +kubebuilder:validation:Optional
	ReplyTo *string `json:"replyTo,omitempty" tf:"reply_to,omitempty"`

	// +kubebuilder:validation:Optional
	ReplyToDisplayName *string `json:"replyToDisplayName,omitempty" tf:"reply_to_display_name,omitempty"`

	// +kubebuilder:validation:Optional
	SSL *bool `json:"ssl,omitempty" tf:"ssl,omitempty"`

	// +kubebuilder:validation:Optional
	Starttls *bool `json:"starttls,omitempty" tf:"starttls,omitempty"`
}

type SecurityDefensesObservation struct {
}

type SecurityDefensesParameters struct {

	// +kubebuilder:validation:Optional
	BruteForceDetection []BruteForceDetectionParameters `json:"bruteForceDetection,omitempty" tf:"brute_force_detection,omitempty"`

	// +kubebuilder:validation:Optional
	Headers []HeadersParameters `json:"headers,omitempty" tf:"headers,omitempty"`
}

type WebAuthnPasswordlessPolicyObservation struct {
}

type WebAuthnPasswordlessPolicyParameters struct {

	// +kubebuilder:validation:Optional
	AcceptableAaguids []*string `json:"acceptableAaguids,omitempty" tf:"acceptable_aaguids,omitempty"`

	// Either none, indirect or direct
	// +kubebuilder:validation:Optional
	AttestationConveyancePreference *string `json:"attestationConveyancePreference,omitempty" tf:"attestation_conveyance_preference,omitempty"`

	// Either platform or cross-platform
	// +kubebuilder:validation:Optional
	AuthenticatorAttachment *string `json:"authenticatorAttachment,omitempty" tf:"authenticator_attachment,omitempty"`

	// +kubebuilder:validation:Optional
	AvoidSameAuthenticatorRegister *bool `json:"avoidSameAuthenticatorRegister,omitempty" tf:"avoid_same_authenticator_register,omitempty"`

	// +kubebuilder:validation:Optional
	CreateTimeout *float64 `json:"createTimeout,omitempty" tf:"create_timeout,omitempty"`

	// +kubebuilder:validation:Optional
	RelyingPartyEntityName *string `json:"relyingPartyEntityName,omitempty" tf:"relying_party_entity_name,omitempty"`

	// +kubebuilder:validation:Optional
	RelyingPartyID *string `json:"relyingPartyId,omitempty" tf:"relying_party_id,omitempty"`

	// Either Yes or No
	// +kubebuilder:validation:Optional
	RequireResidentKey *string `json:"requireResidentKey,omitempty" tf:"require_resident_key,omitempty"`

	// Keycloak lists ES256, ES384, ES512, RS256, RS384, RS512, RS1 at the time of writing
	// +kubebuilder:validation:Optional
	SignatureAlgorithms []*string `json:"signatureAlgorithms,omitempty" tf:"signature_algorithms,omitempty"`

	// Either required, preferred or discouraged
	// +kubebuilder:validation:Optional
	UserVerificationRequirement *string `json:"userVerificationRequirement,omitempty" tf:"user_verification_requirement,omitempty"`
}

type WebAuthnPolicyObservation struct {
}

type WebAuthnPolicyParameters struct {

	// +kubebuilder:validation:Optional
	AcceptableAaguids []*string `json:"acceptableAaguids,omitempty" tf:"acceptable_aaguids,omitempty"`

	// Either none, indirect or direct
	// +kubebuilder:validation:Optional
	AttestationConveyancePreference *string `json:"attestationConveyancePreference,omitempty" tf:"attestation_conveyance_preference,omitempty"`

	// Either platform or cross-platform
	// +kubebuilder:validation:Optional
	AuthenticatorAttachment *string `json:"authenticatorAttachment,omitempty" tf:"authenticator_attachment,omitempty"`

	// +kubebuilder:validation:Optional
	AvoidSameAuthenticatorRegister *bool `json:"avoidSameAuthenticatorRegister,omitempty" tf:"avoid_same_authenticator_register,omitempty"`

	// +kubebuilder:validation:Optional
	CreateTimeout *float64 `json:"createTimeout,omitempty" tf:"create_timeout,omitempty"`

	// +kubebuilder:validation:Optional
	RelyingPartyEntityName *string `json:"relyingPartyEntityName,omitempty" tf:"relying_party_entity_name,omitempty"`

	// +kubebuilder:validation:Optional
	RelyingPartyID *string `json:"relyingPartyId,omitempty" tf:"relying_party_id,omitempty"`

	// Either Yes or No
	// +kubebuilder:validation:Optional
	RequireResidentKey *string `json:"requireResidentKey,omitempty" tf:"require_resident_key,omitempty"`

	// Keycloak lists ES256, ES384, ES512, RS256, RS384, RS512, RS1 at the time of writing
	// +kubebuilder:validation:Optional
	SignatureAlgorithms []*string `json:"signatureAlgorithms,omitempty" tf:"signature_algorithms,omitempty"`

	// Either required, preferred or discouraged
	// +kubebuilder:validation:Optional
	UserVerificationRequirement *string `json:"userVerificationRequirement,omitempty" tf:"user_verification_requirement,omitempty"`
}

// RealmSpec defines the desired state of Realm
type RealmSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     RealmParameters `json:"forProvider"`
}

// RealmStatus defines the observed state of Realm.
type RealmStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        RealmObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// Realm is the Schema for the Realms API. <no value>
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,keycloak}
type Realm struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              RealmSpec   `json:"spec"`
	Status            RealmStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// RealmList contains a list of Realms
type RealmList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Realm `json:"items"`
}

// Repository type metadata.
var (
	Realm_Kind             = "Realm"
	Realm_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: Realm_Kind}.String()
	Realm_KindAPIVersion   = Realm_Kind + "." + CRDGroupVersion.String()
	Realm_GroupVersionKind = CRDGroupVersion.WithKind(Realm_Kind)
)

func init() {
	SchemeBuilder.Register(&Realm{}, &RealmList{})
}
