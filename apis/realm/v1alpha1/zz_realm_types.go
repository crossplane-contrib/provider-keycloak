// SPDX-FileCopyrightText: 2023 The Crossplane Authors <https://crossplane.io>
//
// SPDX-License-Identifier: Apache-2.0

/*
Copyright 2022 Upbound Inc.
*/

// Code generated by upjet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type AuthInitParameters struct {

	// The SMTP server username.
	Username *string `json:"username,omitempty" tf:"username,omitempty"`
}

type AuthObservation struct {

	// The SMTP server username.
	Username *string `json:"username,omitempty" tf:"username,omitempty"`
}

type AuthParameters struct {

	// The SMTP server password.
	// +kubebuilder:validation:Required
	PasswordSecretRef v1.SecretKeySelector `json:"passwordSecretRef" tf:"-"`

	// The SMTP server username.
	// +kubebuilder:validation:Optional
	Username *string `json:"username" tf:"username,omitempty"`
}

type BruteForceDetectionInitParameters struct {

	// When will failure count be reset?
	FailureResetTimeSeconds *float64 `json:"failureResetTimeSeconds,omitempty" tf:"failure_reset_time_seconds,omitempty"`

	MaxFailureWaitSeconds *float64 `json:"maxFailureWaitSeconds,omitempty" tf:"max_failure_wait_seconds,omitempty"`

	// How many failures before wait is triggered.
	MaxLoginFailures *float64 `json:"maxLoginFailures,omitempty" tf:"max_login_failures,omitempty"`

	// How long to wait after a quick login failure.
	MinimumQuickLoginWaitSeconds *float64 `json:"minimumQuickLoginWaitSeconds,omitempty" tf:"minimum_quick_login_wait_seconds,omitempty"`

	// When true, this will lock the user permanently when the user exceeds the maximum login failures.
	PermanentLockout *bool `json:"permanentLockout,omitempty" tf:"permanent_lockout,omitempty"`

	// Configures the amount of time, in milliseconds, for consecutive failures to lock a user out.
	QuickLoginCheckMilliSeconds *float64 `json:"quickLoginCheckMilliSeconds,omitempty" tf:"quick_login_check_milli_seconds,omitempty"`

	// This represents the amount of time a user should be locked out when the login failure threshold has been met.
	WaitIncrementSeconds *float64 `json:"waitIncrementSeconds,omitempty" tf:"wait_increment_seconds,omitempty"`
}

type BruteForceDetectionObservation struct {

	// When will failure count be reset?
	FailureResetTimeSeconds *float64 `json:"failureResetTimeSeconds,omitempty" tf:"failure_reset_time_seconds,omitempty"`

	MaxFailureWaitSeconds *float64 `json:"maxFailureWaitSeconds,omitempty" tf:"max_failure_wait_seconds,omitempty"`

	// How many failures before wait is triggered.
	MaxLoginFailures *float64 `json:"maxLoginFailures,omitempty" tf:"max_login_failures,omitempty"`

	// How long to wait after a quick login failure.
	MinimumQuickLoginWaitSeconds *float64 `json:"minimumQuickLoginWaitSeconds,omitempty" tf:"minimum_quick_login_wait_seconds,omitempty"`

	// When true, this will lock the user permanently when the user exceeds the maximum login failures.
	PermanentLockout *bool `json:"permanentLockout,omitempty" tf:"permanent_lockout,omitempty"`

	// Configures the amount of time, in milliseconds, for consecutive failures to lock a user out.
	QuickLoginCheckMilliSeconds *float64 `json:"quickLoginCheckMilliSeconds,omitempty" tf:"quick_login_check_milli_seconds,omitempty"`

	// This represents the amount of time a user should be locked out when the login failure threshold has been met.
	WaitIncrementSeconds *float64 `json:"waitIncrementSeconds,omitempty" tf:"wait_increment_seconds,omitempty"`
}

type BruteForceDetectionParameters struct {

	// When will failure count be reset?
	// +kubebuilder:validation:Optional
	FailureResetTimeSeconds *float64 `json:"failureResetTimeSeconds,omitempty" tf:"failure_reset_time_seconds,omitempty"`

	// +kubebuilder:validation:Optional
	MaxFailureWaitSeconds *float64 `json:"maxFailureWaitSeconds,omitempty" tf:"max_failure_wait_seconds,omitempty"`

	// How many failures before wait is triggered.
	// +kubebuilder:validation:Optional
	MaxLoginFailures *float64 `json:"maxLoginFailures,omitempty" tf:"max_login_failures,omitempty"`

	// How long to wait after a quick login failure.
	// +kubebuilder:validation:Optional
	MinimumQuickLoginWaitSeconds *float64 `json:"minimumQuickLoginWaitSeconds,omitempty" tf:"minimum_quick_login_wait_seconds,omitempty"`

	// When true, this will lock the user permanently when the user exceeds the maximum login failures.
	// +kubebuilder:validation:Optional
	PermanentLockout *bool `json:"permanentLockout,omitempty" tf:"permanent_lockout,omitempty"`

	// Configures the amount of time, in milliseconds, for consecutive failures to lock a user out.
	// +kubebuilder:validation:Optional
	QuickLoginCheckMilliSeconds *float64 `json:"quickLoginCheckMilliSeconds,omitempty" tf:"quick_login_check_milli_seconds,omitempty"`

	// This represents the amount of time a user should be locked out when the login failure threshold has been met.
	// +kubebuilder:validation:Optional
	WaitIncrementSeconds *float64 `json:"waitIncrementSeconds,omitempty" tf:"wait_increment_seconds,omitempty"`
}

type HeadersInitParameters struct {

	// Sets the Content Security Policy, which can be used for prevent pages from being included by non-origin iframes. More information can be found in the W3C-CSP Abstract.
	ContentSecurityPolicy *string `json:"contentSecurityPolicy,omitempty" tf:"content_security_policy,omitempty"`

	// Used for testing Content Security Policies.
	ContentSecurityPolicyReportOnly *string `json:"contentSecurityPolicyReportOnly,omitempty" tf:"content_security_policy_report_only,omitempty"`

	// The Script-Transport-Security HTTP header tells browsers to always use HTTPS.
	StrictTransportSecurity *string `json:"strictTransportSecurity,omitempty" tf:"strict_transport_security,omitempty"`

	// Sets the X-Content-Type-Options, which can be used for prevent MIME-sniffing a response away from the declared content-type
	XContentTypeOptions *string `json:"xContentTypeOptions,omitempty" tf:"x_content_type_options,omitempty"`

	// Sets the x-frame-option, which can be used to prevent pages from being included by non-origin iframes. More information can be found in the RFC7034
	XFrameOptions *string `json:"xFrameOptions,omitempty" tf:"x_frame_options,omitempty"`

	// Prevent pages from appearing in search engines.
	XRobotsTag *string `json:"xRobotsTag,omitempty" tf:"x_robots_tag,omitempty"`

	// This header configures the Cross-site scripting (XSS) filter in your browser.
	XXSSProtection *string `json:"xXssProtection,omitempty" tf:"x_xss_protection,omitempty"`
}

type HeadersObservation struct {

	// Sets the Content Security Policy, which can be used for prevent pages from being included by non-origin iframes. More information can be found in the W3C-CSP Abstract.
	ContentSecurityPolicy *string `json:"contentSecurityPolicy,omitempty" tf:"content_security_policy,omitempty"`

	// Used for testing Content Security Policies.
	ContentSecurityPolicyReportOnly *string `json:"contentSecurityPolicyReportOnly,omitempty" tf:"content_security_policy_report_only,omitempty"`

	// The Script-Transport-Security HTTP header tells browsers to always use HTTPS.
	StrictTransportSecurity *string `json:"strictTransportSecurity,omitempty" tf:"strict_transport_security,omitempty"`

	// Sets the X-Content-Type-Options, which can be used for prevent MIME-sniffing a response away from the declared content-type
	XContentTypeOptions *string `json:"xContentTypeOptions,omitempty" tf:"x_content_type_options,omitempty"`

	// Sets the x-frame-option, which can be used to prevent pages from being included by non-origin iframes. More information can be found in the RFC7034
	XFrameOptions *string `json:"xFrameOptions,omitempty" tf:"x_frame_options,omitempty"`

	// Prevent pages from appearing in search engines.
	XRobotsTag *string `json:"xRobotsTag,omitempty" tf:"x_robots_tag,omitempty"`

	// This header configures the Cross-site scripting (XSS) filter in your browser.
	XXSSProtection *string `json:"xXssProtection,omitempty" tf:"x_xss_protection,omitempty"`
}

type HeadersParameters struct {

	// Sets the Content Security Policy, which can be used for prevent pages from being included by non-origin iframes. More information can be found in the W3C-CSP Abstract.
	// +kubebuilder:validation:Optional
	ContentSecurityPolicy *string `json:"contentSecurityPolicy,omitempty" tf:"content_security_policy,omitempty"`

	// Used for testing Content Security Policies.
	// +kubebuilder:validation:Optional
	ContentSecurityPolicyReportOnly *string `json:"contentSecurityPolicyReportOnly,omitempty" tf:"content_security_policy_report_only,omitempty"`

	// The Script-Transport-Security HTTP header tells browsers to always use HTTPS.
	// +kubebuilder:validation:Optional
	StrictTransportSecurity *string `json:"strictTransportSecurity,omitempty" tf:"strict_transport_security,omitempty"`

	// Sets the X-Content-Type-Options, which can be used for prevent MIME-sniffing a response away from the declared content-type
	// +kubebuilder:validation:Optional
	XContentTypeOptions *string `json:"xContentTypeOptions,omitempty" tf:"x_content_type_options,omitempty"`

	// Sets the x-frame-option, which can be used to prevent pages from being included by non-origin iframes. More information can be found in the RFC7034
	// +kubebuilder:validation:Optional
	XFrameOptions *string `json:"xFrameOptions,omitempty" tf:"x_frame_options,omitempty"`

	// Prevent pages from appearing in search engines.
	// +kubebuilder:validation:Optional
	XRobotsTag *string `json:"xRobotsTag,omitempty" tf:"x_robots_tag,omitempty"`

	// This header configures the Cross-site scripting (XSS) filter in your browser.
	// +kubebuilder:validation:Optional
	XXSSProtection *string `json:"xXssProtection,omitempty" tf:"x_xss_protection,omitempty"`
}

type InternationalizationInitParameters struct {

	// The locale to use by default. This locale code must be present within the supported_locales list.
	DefaultLocale *string `json:"defaultLocale,omitempty" tf:"default_locale,omitempty"`

	// A list of ISO 639-1 locale codes that the realm should support.
	// +listType=set
	SupportedLocales []*string `json:"supportedLocales,omitempty" tf:"supported_locales,omitempty"`
}

type InternationalizationObservation struct {

	// The locale to use by default. This locale code must be present within the supported_locales list.
	DefaultLocale *string `json:"defaultLocale,omitempty" tf:"default_locale,omitempty"`

	// A list of ISO 639-1 locale codes that the realm should support.
	// +listType=set
	SupportedLocales []*string `json:"supportedLocales,omitempty" tf:"supported_locales,omitempty"`
}

type InternationalizationParameters struct {

	// The locale to use by default. This locale code must be present within the supported_locales list.
	// +kubebuilder:validation:Optional
	DefaultLocale *string `json:"defaultLocale" tf:"default_locale,omitempty"`

	// A list of ISO 639-1 locale codes that the realm should support.
	// +kubebuilder:validation:Optional
	// +listType=set
	SupportedLocales []*string `json:"supportedLocales" tf:"supported_locales,omitempty"`
}

type OtpPolicyInitParameters struct {

	// What hashing algorithm should be used to generate the OTP, Valid options are HmacSHA1,HmacSHA256 and HmacSHA512. Defaults to HmacSHA1.
	// What hashing algorithm should be used to generate the OTP.
	Algorithm *string `json:"algorithm,omitempty" tf:"algorithm,omitempty"`

	// How many digits the OTP have. Defaults to 6.
	Digits *float64 `json:"digits,omitempty" tf:"digits,omitempty"`

	// What should the initial counter value be. Defaults to 2.
	InitialCounter *float64 `json:"initialCounter,omitempty" tf:"initial_counter,omitempty"`

	// How far ahead should the server look just in case the token generator and server are out of time sync or counter sync. Defaults to 1.
	LookAheadWindow *float64 `json:"lookAheadWindow,omitempty" tf:"look_ahead_window,omitempty"`

	// How many seconds should an OTP token be valid. Defaults to 30.
	Period *float64 `json:"period,omitempty" tf:"period,omitempty"`

	// One Time Password Type, supported Values are totp for Time-Based One Time Password and hotp for Counter Based. Defaults to totp.
	// OTP Type, totp for Time-Based One Time Password or hotp for counter base one time password
	Type *string `json:"type,omitempty" tf:"type,omitempty"`
}

type OtpPolicyObservation struct {

	// What hashing algorithm should be used to generate the OTP, Valid options are HmacSHA1,HmacSHA256 and HmacSHA512. Defaults to HmacSHA1.
	// What hashing algorithm should be used to generate the OTP.
	Algorithm *string `json:"algorithm,omitempty" tf:"algorithm,omitempty"`

	// How many digits the OTP have. Defaults to 6.
	Digits *float64 `json:"digits,omitempty" tf:"digits,omitempty"`

	// What should the initial counter value be. Defaults to 2.
	InitialCounter *float64 `json:"initialCounter,omitempty" tf:"initial_counter,omitempty"`

	// How far ahead should the server look just in case the token generator and server are out of time sync or counter sync. Defaults to 1.
	LookAheadWindow *float64 `json:"lookAheadWindow,omitempty" tf:"look_ahead_window,omitempty"`

	// How many seconds should an OTP token be valid. Defaults to 30.
	Period *float64 `json:"period,omitempty" tf:"period,omitempty"`

	// One Time Password Type, supported Values are totp for Time-Based One Time Password and hotp for Counter Based. Defaults to totp.
	// OTP Type, totp for Time-Based One Time Password or hotp for counter base one time password
	Type *string `json:"type,omitempty" tf:"type,omitempty"`
}

type OtpPolicyParameters struct {

	// What hashing algorithm should be used to generate the OTP, Valid options are HmacSHA1,HmacSHA256 and HmacSHA512. Defaults to HmacSHA1.
	// What hashing algorithm should be used to generate the OTP.
	// +kubebuilder:validation:Optional
	Algorithm *string `json:"algorithm,omitempty" tf:"algorithm,omitempty"`

	// How many digits the OTP have. Defaults to 6.
	// +kubebuilder:validation:Optional
	Digits *float64 `json:"digits,omitempty" tf:"digits,omitempty"`

	// What should the initial counter value be. Defaults to 2.
	// +kubebuilder:validation:Optional
	InitialCounter *float64 `json:"initialCounter,omitempty" tf:"initial_counter,omitempty"`

	// How far ahead should the server look just in case the token generator and server are out of time sync or counter sync. Defaults to 1.
	// +kubebuilder:validation:Optional
	LookAheadWindow *float64 `json:"lookAheadWindow,omitempty" tf:"look_ahead_window,omitempty"`

	// How many seconds should an OTP token be valid. Defaults to 30.
	// +kubebuilder:validation:Optional
	Period *float64 `json:"period,omitempty" tf:"period,omitempty"`

	// One Time Password Type, supported Values are totp for Time-Based One Time Password and hotp for Counter Based. Defaults to totp.
	// OTP Type, totp for Time-Based One Time Password or hotp for counter base one time password
	// +kubebuilder:validation:Optional
	Type *string `json:"type,omitempty" tf:"type,omitempty"`
}

type RealmInitParameters struct {

	// The maximum amount of time a client has to finish the authorization code flow.
	AccessCodeLifespan *string `json:"accessCodeLifespan,omitempty" tf:"access_code_lifespan,omitempty"`

	// The maximum amount of time a user is permitted to stay on the login page before the authentication process must be restarted.
	AccessCodeLifespanLogin *string `json:"accessCodeLifespanLogin,omitempty" tf:"access_code_lifespan_login,omitempty"`

	// The maximum amount of time a user has to complete login related actions, such as updating a password.
	AccessCodeLifespanUserAction *string `json:"accessCodeLifespanUserAction,omitempty" tf:"access_code_lifespan_user_action,omitempty"`

	// The amount of time an access token can be used before it expires.
	AccessTokenLifespan *string `json:"accessTokenLifespan,omitempty" tf:"access_token_lifespan,omitempty"`

	// The amount of time an access token issued with the OpenID Connect Implicit Flow can be used before it expires.
	AccessTokenLifespanForImplicitFlow *string `json:"accessTokenLifespanForImplicitFlow,omitempty" tf:"access_token_lifespan_for_implicit_flow,omitempty"`

	// Used for account management pages.
	AccountTheme *string `json:"accountTheme,omitempty" tf:"account_theme,omitempty"`

	// The maximum time a user has to use an admin-generated permit before it expires.
	ActionTokenGeneratedByAdminLifespan *string `json:"actionTokenGeneratedByAdminLifespan,omitempty" tf:"action_token_generated_by_admin_lifespan,omitempty"`

	// The maximum time a user has to use a user-generated permit before it expires.
	ActionTokenGeneratedByUserLifespan *string `json:"actionTokenGeneratedByUserLifespan,omitempty" tf:"action_token_generated_by_user_lifespan,omitempty"`

	// Used for the admin console.
	AdminTheme *string `json:"adminTheme,omitempty" tf:"admin_theme,omitempty"`

	// A map of custom attributes to add to the realm.
	// +mapType=granular
	Attributes map[string]*string `json:"attributes,omitempty" tf:"attributes,omitempty"`

	// The desired flow for browser authentication. Defaults to browser.
	// Which flow should be used for BrowserFlow
	BrowserFlow *string `json:"browserFlow,omitempty" tf:"browser_flow,omitempty"`

	// The desired flow for client authentication. Defaults to clients.
	// Which flow should be used for ClientAuthenticationFlow
	ClientAuthenticationFlow *string `json:"clientAuthenticationFlow,omitempty" tf:"client_authentication_flow,omitempty"`

	// The amount of time a session can be idle before it expires. Users can override it for individual clients.
	ClientSessionIdleTimeout *string `json:"clientSessionIdleTimeout,omitempty" tf:"client_session_idle_timeout,omitempty"`

	// The maximum amount of time before a session expires regardless of activity. Users can override it for individual clients.
	ClientSessionMaxLifespan *string `json:"clientSessionMaxLifespan,omitempty" tf:"client_session_max_lifespan,omitempty"`

	// A list of default default client scopes to be used for client definitions. Defaults to [] or keycloak's built-in default default client-scopes.
	// +listType=set
	DefaultDefaultClientScopes []*string `json:"defaultDefaultClientScopes,omitempty" tf:"default_default_client_scopes,omitempty"`

	// A list of default optional client scopes to be used for client definitions. Defaults to [] or keycloak's built-in default optional client-scopes.
	// +listType=set
	DefaultOptionalClientScopes []*string `json:"defaultOptionalClientScopes,omitempty" tf:"default_optional_client_scopes,omitempty"`

	// Default algorithm used to sign tokens for the realm.
	DefaultSignatureAlgorithm *string `json:"defaultSignatureAlgorithm,omitempty" tf:"default_signature_algorithm,omitempty"`

	// The desired flow for direct access authentication. Defaults to direct grant.
	// Which flow should be used for DirectGrantFlow
	DirectGrantFlow *string `json:"directGrantFlow,omitempty" tf:"direct_grant_flow,omitempty"`

	// The display name for the realm that is shown when logging in to the admin console.
	DisplayName *string `json:"displayName,omitempty" tf:"display_name,omitempty"`

	// The display name for the realm that is rendered as HTML on the screen when logging in to the admin console.
	DisplayNameHTML *string `json:"displayNameHtml,omitempty" tf:"display_name_html,omitempty"`

	// The desired flow for Docker authentication. Defaults to docker auth.
	// Which flow should be used for DockerAuthenticationFlow
	DockerAuthenticationFlow *string `json:"dockerAuthenticationFlow,omitempty" tf:"docker_authentication_flow,omitempty"`

	// When true, multiple users will be allowed to have the same email address. This argument must be set to false if login_with_email_allowed is set to true.
	DuplicateEmailsAllowed *bool `json:"duplicateEmailsAllowed,omitempty" tf:"duplicate_emails_allowed,omitempty"`

	// When true, the username field is editable.
	EditUsernameAllowed *bool `json:"editUsernameAllowed,omitempty" tf:"edit_username_allowed,omitempty"`

	// Used for emails that are sent by Keycloak.
	EmailTheme *string `json:"emailTheme,omitempty" tf:"email_theme,omitempty"`

	// When false, users and clients will not be able to access this realm. Defaults to true.
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`

	// When specified, this will be used as the realm's internal ID within Keycloak. When not specified, the realm's internal ID will be set to the realm's name.
	InternalID *string `json:"internalId,omitempty" tf:"internal_id,omitempty"`

	Internationalization []InternationalizationInitParameters `json:"internationalization,omitempty" tf:"internationalization,omitempty"`

	// Used for the login, forgot password, and registration pages.
	LoginTheme *string `json:"loginTheme,omitempty" tf:"login_theme,omitempty"`

	// When true, users may log in with their email address.
	LoginWithEmailAllowed *bool `json:"loginWithEmailAllowed,omitempty" tf:"login_with_email_allowed,omitempty"`

	// The maximum amount of time a client has to finish the device code flow before it expires.
	Oauth2DeviceCodeLifespan *string `json:"oauth2DeviceCodeLifespan,omitempty" tf:"oauth2_device_code_lifespan,omitempty"`

	// The minimum amount of time in seconds that the client should wait between polling requests to the token endpoint.
	Oauth2DevicePollingInterval *float64 `json:"oauth2DevicePollingInterval,omitempty" tf:"oauth2_device_polling_interval,omitempty"`

	// The amount of time an offline session can be idle before it expires.
	OfflineSessionIdleTimeout *string `json:"offlineSessionIdleTimeout,omitempty" tf:"offline_session_idle_timeout,omitempty"`

	// The maximum amount of time before an offline session expires regardless of activity.
	OfflineSessionMaxLifespan *string `json:"offlineSessionMaxLifespan,omitempty" tf:"offline_session_max_lifespan,omitempty"`

	// Enable offline_session_max_lifespan.
	OfflineSessionMaxLifespanEnabled *bool `json:"offlineSessionMaxLifespanEnabled,omitempty" tf:"offline_session_max_lifespan_enabled,omitempty"`

	OtpPolicy []OtpPolicyInitParameters `json:"otpPolicy,omitempty" tf:"otp_policy,omitempty"`

	// The password policy for users within the realm.
	// String that represents the passwordPolicies that are in place. Each policy is separated with " and ". Supported policies can be found in the server-info providers page. example: "upperCase(1) and length(8) and forceExpiredPasswordChange(365) and notUsername(undefined)"
	PasswordPolicy *string `json:"passwordPolicy,omitempty" tf:"password_policy,omitempty"`

	// The name of the realm. This is unique across Keycloak. This will also be used as the realm's internal ID within Keycloak.
	Realm *string `json:"realm,omitempty" tf:"realm,omitempty"`

	// Maximum number of times a refresh token can be reused before they are revoked. If unspecified and 'revoke_refresh_token' is enabled the default value is 0 and refresh tokens can not be reused.
	RefreshTokenMaxReuse *float64 `json:"refreshTokenMaxReuse,omitempty" tf:"refresh_token_max_reuse,omitempty"`

	// When true, user registration will be enabled, and a link for registration will be displayed on the login page.
	RegistrationAllowed *bool `json:"registrationAllowed,omitempty" tf:"registration_allowed,omitempty"`

	// When true, the user's email will be used as their username during registration.
	RegistrationEmailAsUsername *bool `json:"registrationEmailAsUsername,omitempty" tf:"registration_email_as_username,omitempty"`

	// The desired flow for user registration. Defaults to registration.
	// Which flow should be used for RegistrationFlow
	RegistrationFlow *string `json:"registrationFlow,omitempty" tf:"registration_flow,omitempty"`

	// When true, a "remember me" checkbox will be displayed on the login page, and the user's session will not expire between browser restarts.
	RememberMe *bool `json:"rememberMe,omitempty" tf:"remember_me,omitempty"`

	// The desired flow to use when a user attempts to reset their credentials. Defaults to reset credentials.
	// Which flow should be used for ResetCredentialsFlow
	ResetCredentialsFlow *string `json:"resetCredentialsFlow,omitempty" tf:"reset_credentials_flow,omitempty"`

	// When true, a "forgot password" link will be displayed on the login page.
	ResetPasswordAllowed *bool `json:"resetPasswordAllowed,omitempty" tf:"reset_password_allowed,omitempty"`

	// If enabled a refresh token can only be used number of times specified in 'refresh_token_max_reuse' before they are revoked. If unspecified, refresh tokens can be reused.
	RevokeRefreshToken *bool `json:"revokeRefreshToken,omitempty" tf:"revoke_refresh_token,omitempty"`

	SMTPServer []SMTPServerInitParameters `json:"smtpServer,omitempty" tf:"smtp_server,omitempty"`

	// Can be one of following values: 'none, 'external' or 'all'
	// SSL Required: Values can be 'none', 'external' or 'all'.
	SSLRequired *string `json:"sslRequired,omitempty" tf:"ssl_required,omitempty"`

	SecurityDefenses []SecurityDefensesInitParameters `json:"securityDefenses,omitempty" tf:"security_defenses,omitempty"`

	// The amount of time a session can be idle before it expires.
	SsoSessionIdleTimeout *string `json:"ssoSessionIdleTimeout,omitempty" tf:"sso_session_idle_timeout,omitempty"`

	// Similar to sso_session_idle_timeout, but used when a user clicks "Remember Me". If not set, Keycloak will default to the value of sso_session_idle_timeout.
	SsoSessionIdleTimeoutRememberMe *string `json:"ssoSessionIdleTimeoutRememberMe,omitempty" tf:"sso_session_idle_timeout_remember_me,omitempty"`

	// The maximum amount of time before a session expires regardless of activity.
	SsoSessionMaxLifespan *string `json:"ssoSessionMaxLifespan,omitempty" tf:"sso_session_max_lifespan,omitempty"`

	// Similar to sso_session_max_lifespan, but used when a user clicks "Remember Me". If not set, Keycloak will default to the value of sso_session_max_lifespan.
	SsoSessionMaxLifespanRememberMe *string `json:"ssoSessionMaxLifespanRememberMe,omitempty" tf:"sso_session_max_lifespan_remember_me,omitempty"`

	// When true, users are allowed to manage their own resources. Defaults to false.
	UserManagedAccess *bool `json:"userManagedAccess,omitempty" tf:"user_managed_access,omitempty"`

	// When true, users are required to verify their email address after registration and after email address changes.
	VerifyEmail *bool `json:"verifyEmail,omitempty" tf:"verify_email,omitempty"`

	// Configuration for WebAuthn Passwordless Policy authentication.
	WebAuthnPasswordlessPolicy []WebAuthnPasswordlessPolicyInitParameters `json:"webAuthnPasswordlessPolicy,omitempty" tf:"web_authn_passwordless_policy,omitempty"`

	// Configuration for WebAuthn Policy authentication.
	WebAuthnPolicy []WebAuthnPolicyInitParameters `json:"webAuthnPolicy,omitempty" tf:"web_authn_policy,omitempty"`
}

type RealmObservation struct {

	// The maximum amount of time a client has to finish the authorization code flow.
	AccessCodeLifespan *string `json:"accessCodeLifespan,omitempty" tf:"access_code_lifespan,omitempty"`

	// The maximum amount of time a user is permitted to stay on the login page before the authentication process must be restarted.
	AccessCodeLifespanLogin *string `json:"accessCodeLifespanLogin,omitempty" tf:"access_code_lifespan_login,omitempty"`

	// The maximum amount of time a user has to complete login related actions, such as updating a password.
	AccessCodeLifespanUserAction *string `json:"accessCodeLifespanUserAction,omitempty" tf:"access_code_lifespan_user_action,omitempty"`

	// The amount of time an access token can be used before it expires.
	AccessTokenLifespan *string `json:"accessTokenLifespan,omitempty" tf:"access_token_lifespan,omitempty"`

	// The amount of time an access token issued with the OpenID Connect Implicit Flow can be used before it expires.
	AccessTokenLifespanForImplicitFlow *string `json:"accessTokenLifespanForImplicitFlow,omitempty" tf:"access_token_lifespan_for_implicit_flow,omitempty"`

	// Used for account management pages.
	AccountTheme *string `json:"accountTheme,omitempty" tf:"account_theme,omitempty"`

	// The maximum time a user has to use an admin-generated permit before it expires.
	ActionTokenGeneratedByAdminLifespan *string `json:"actionTokenGeneratedByAdminLifespan,omitempty" tf:"action_token_generated_by_admin_lifespan,omitempty"`

	// The maximum time a user has to use a user-generated permit before it expires.
	ActionTokenGeneratedByUserLifespan *string `json:"actionTokenGeneratedByUserLifespan,omitempty" tf:"action_token_generated_by_user_lifespan,omitempty"`

	// Used for the admin console.
	AdminTheme *string `json:"adminTheme,omitempty" tf:"admin_theme,omitempty"`

	// A map of custom attributes to add to the realm.
	// +mapType=granular
	Attributes map[string]*string `json:"attributes,omitempty" tf:"attributes,omitempty"`

	// The desired flow for browser authentication. Defaults to browser.
	// Which flow should be used for BrowserFlow
	BrowserFlow *string `json:"browserFlow,omitempty" tf:"browser_flow,omitempty"`

	// The desired flow for client authentication. Defaults to clients.
	// Which flow should be used for ClientAuthenticationFlow
	ClientAuthenticationFlow *string `json:"clientAuthenticationFlow,omitempty" tf:"client_authentication_flow,omitempty"`

	// The amount of time a session can be idle before it expires. Users can override it for individual clients.
	ClientSessionIdleTimeout *string `json:"clientSessionIdleTimeout,omitempty" tf:"client_session_idle_timeout,omitempty"`

	// The maximum amount of time before a session expires regardless of activity. Users can override it for individual clients.
	ClientSessionMaxLifespan *string `json:"clientSessionMaxLifespan,omitempty" tf:"client_session_max_lifespan,omitempty"`

	// A list of default default client scopes to be used for client definitions. Defaults to [] or keycloak's built-in default default client-scopes.
	// +listType=set
	DefaultDefaultClientScopes []*string `json:"defaultDefaultClientScopes,omitempty" tf:"default_default_client_scopes,omitempty"`

	// A list of default optional client scopes to be used for client definitions. Defaults to [] or keycloak's built-in default optional client-scopes.
	// +listType=set
	DefaultOptionalClientScopes []*string `json:"defaultOptionalClientScopes,omitempty" tf:"default_optional_client_scopes,omitempty"`

	// Default algorithm used to sign tokens for the realm.
	DefaultSignatureAlgorithm *string `json:"defaultSignatureAlgorithm,omitempty" tf:"default_signature_algorithm,omitempty"`

	// The desired flow for direct access authentication. Defaults to direct grant.
	// Which flow should be used for DirectGrantFlow
	DirectGrantFlow *string `json:"directGrantFlow,omitempty" tf:"direct_grant_flow,omitempty"`

	// The display name for the realm that is shown when logging in to the admin console.
	DisplayName *string `json:"displayName,omitempty" tf:"display_name,omitempty"`

	// The display name for the realm that is rendered as HTML on the screen when logging in to the admin console.
	DisplayNameHTML *string `json:"displayNameHtml,omitempty" tf:"display_name_html,omitempty"`

	// The desired flow for Docker authentication. Defaults to docker auth.
	// Which flow should be used for DockerAuthenticationFlow
	DockerAuthenticationFlow *string `json:"dockerAuthenticationFlow,omitempty" tf:"docker_authentication_flow,omitempty"`

	// When true, multiple users will be allowed to have the same email address. This argument must be set to false if login_with_email_allowed is set to true.
	DuplicateEmailsAllowed *bool `json:"duplicateEmailsAllowed,omitempty" tf:"duplicate_emails_allowed,omitempty"`

	// When true, the username field is editable.
	EditUsernameAllowed *bool `json:"editUsernameAllowed,omitempty" tf:"edit_username_allowed,omitempty"`

	// Used for emails that are sent by Keycloak.
	EmailTheme *string `json:"emailTheme,omitempty" tf:"email_theme,omitempty"`

	// When false, users and clients will not be able to access this realm. Defaults to true.
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`

	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// When specified, this will be used as the realm's internal ID within Keycloak. When not specified, the realm's internal ID will be set to the realm's name.
	InternalID *string `json:"internalId,omitempty" tf:"internal_id,omitempty"`

	Internationalization []InternationalizationObservation `json:"internationalization,omitempty" tf:"internationalization,omitempty"`

	// Used for the login, forgot password, and registration pages.
	LoginTheme *string `json:"loginTheme,omitempty" tf:"login_theme,omitempty"`

	// When true, users may log in with their email address.
	LoginWithEmailAllowed *bool `json:"loginWithEmailAllowed,omitempty" tf:"login_with_email_allowed,omitempty"`

	// The maximum amount of time a client has to finish the device code flow before it expires.
	Oauth2DeviceCodeLifespan *string `json:"oauth2DeviceCodeLifespan,omitempty" tf:"oauth2_device_code_lifespan,omitempty"`

	// The minimum amount of time in seconds that the client should wait between polling requests to the token endpoint.
	Oauth2DevicePollingInterval *float64 `json:"oauth2DevicePollingInterval,omitempty" tf:"oauth2_device_polling_interval,omitempty"`

	// The amount of time an offline session can be idle before it expires.
	OfflineSessionIdleTimeout *string `json:"offlineSessionIdleTimeout,omitempty" tf:"offline_session_idle_timeout,omitempty"`

	// The maximum amount of time before an offline session expires regardless of activity.
	OfflineSessionMaxLifespan *string `json:"offlineSessionMaxLifespan,omitempty" tf:"offline_session_max_lifespan,omitempty"`

	// Enable offline_session_max_lifespan.
	OfflineSessionMaxLifespanEnabled *bool `json:"offlineSessionMaxLifespanEnabled,omitempty" tf:"offline_session_max_lifespan_enabled,omitempty"`

	OtpPolicy []OtpPolicyObservation `json:"otpPolicy,omitempty" tf:"otp_policy,omitempty"`

	// The password policy for users within the realm.
	// String that represents the passwordPolicies that are in place. Each policy is separated with " and ". Supported policies can be found in the server-info providers page. example: "upperCase(1) and length(8) and forceExpiredPasswordChange(365) and notUsername(undefined)"
	PasswordPolicy *string `json:"passwordPolicy,omitempty" tf:"password_policy,omitempty"`

	// The name of the realm. This is unique across Keycloak. This will also be used as the realm's internal ID within Keycloak.
	Realm *string `json:"realm,omitempty" tf:"realm,omitempty"`

	// Maximum number of times a refresh token can be reused before they are revoked. If unspecified and 'revoke_refresh_token' is enabled the default value is 0 and refresh tokens can not be reused.
	RefreshTokenMaxReuse *float64 `json:"refreshTokenMaxReuse,omitempty" tf:"refresh_token_max_reuse,omitempty"`

	// When true, user registration will be enabled, and a link for registration will be displayed on the login page.
	RegistrationAllowed *bool `json:"registrationAllowed,omitempty" tf:"registration_allowed,omitempty"`

	// When true, the user's email will be used as their username during registration.
	RegistrationEmailAsUsername *bool `json:"registrationEmailAsUsername,omitempty" tf:"registration_email_as_username,omitempty"`

	// The desired flow for user registration. Defaults to registration.
	// Which flow should be used for RegistrationFlow
	RegistrationFlow *string `json:"registrationFlow,omitempty" tf:"registration_flow,omitempty"`

	// When true, a "remember me" checkbox will be displayed on the login page, and the user's session will not expire between browser restarts.
	RememberMe *bool `json:"rememberMe,omitempty" tf:"remember_me,omitempty"`

	// The desired flow to use when a user attempts to reset their credentials. Defaults to reset credentials.
	// Which flow should be used for ResetCredentialsFlow
	ResetCredentialsFlow *string `json:"resetCredentialsFlow,omitempty" tf:"reset_credentials_flow,omitempty"`

	// When true, a "forgot password" link will be displayed on the login page.
	ResetPasswordAllowed *bool `json:"resetPasswordAllowed,omitempty" tf:"reset_password_allowed,omitempty"`

	// If enabled a refresh token can only be used number of times specified in 'refresh_token_max_reuse' before they are revoked. If unspecified, refresh tokens can be reused.
	RevokeRefreshToken *bool `json:"revokeRefreshToken,omitempty" tf:"revoke_refresh_token,omitempty"`

	SMTPServer []SMTPServerObservation `json:"smtpServer,omitempty" tf:"smtp_server,omitempty"`

	// Can be one of following values: 'none, 'external' or 'all'
	// SSL Required: Values can be 'none', 'external' or 'all'.
	SSLRequired *string `json:"sslRequired,omitempty" tf:"ssl_required,omitempty"`

	SecurityDefenses []SecurityDefensesObservation `json:"securityDefenses,omitempty" tf:"security_defenses,omitempty"`

	// The amount of time a session can be idle before it expires.
	SsoSessionIdleTimeout *string `json:"ssoSessionIdleTimeout,omitempty" tf:"sso_session_idle_timeout,omitempty"`

	// Similar to sso_session_idle_timeout, but used when a user clicks "Remember Me". If not set, Keycloak will default to the value of sso_session_idle_timeout.
	SsoSessionIdleTimeoutRememberMe *string `json:"ssoSessionIdleTimeoutRememberMe,omitempty" tf:"sso_session_idle_timeout_remember_me,omitempty"`

	// The maximum amount of time before a session expires regardless of activity.
	SsoSessionMaxLifespan *string `json:"ssoSessionMaxLifespan,omitempty" tf:"sso_session_max_lifespan,omitempty"`

	// Similar to sso_session_max_lifespan, but used when a user clicks "Remember Me". If not set, Keycloak will default to the value of sso_session_max_lifespan.
	SsoSessionMaxLifespanRememberMe *string `json:"ssoSessionMaxLifespanRememberMe,omitempty" tf:"sso_session_max_lifespan_remember_me,omitempty"`

	// When true, users are allowed to manage their own resources. Defaults to false.
	UserManagedAccess *bool `json:"userManagedAccess,omitempty" tf:"user_managed_access,omitempty"`

	// When true, users are required to verify their email address after registration and after email address changes.
	VerifyEmail *bool `json:"verifyEmail,omitempty" tf:"verify_email,omitempty"`

	// Configuration for WebAuthn Passwordless Policy authentication.
	WebAuthnPasswordlessPolicy []WebAuthnPasswordlessPolicyObservation `json:"webAuthnPasswordlessPolicy,omitempty" tf:"web_authn_passwordless_policy,omitempty"`

	// Configuration for WebAuthn Policy authentication.
	WebAuthnPolicy []WebAuthnPolicyObservation `json:"webAuthnPolicy,omitempty" tf:"web_authn_policy,omitempty"`
}

type RealmParameters struct {

	// The maximum amount of time a client has to finish the authorization code flow.
	// +kubebuilder:validation:Optional
	AccessCodeLifespan *string `json:"accessCodeLifespan,omitempty" tf:"access_code_lifespan,omitempty"`

	// The maximum amount of time a user is permitted to stay on the login page before the authentication process must be restarted.
	// +kubebuilder:validation:Optional
	AccessCodeLifespanLogin *string `json:"accessCodeLifespanLogin,omitempty" tf:"access_code_lifespan_login,omitempty"`

	// The maximum amount of time a user has to complete login related actions, such as updating a password.
	// +kubebuilder:validation:Optional
	AccessCodeLifespanUserAction *string `json:"accessCodeLifespanUserAction,omitempty" tf:"access_code_lifespan_user_action,omitempty"`

	// The amount of time an access token can be used before it expires.
	// +kubebuilder:validation:Optional
	AccessTokenLifespan *string `json:"accessTokenLifespan,omitempty" tf:"access_token_lifespan,omitempty"`

	// The amount of time an access token issued with the OpenID Connect Implicit Flow can be used before it expires.
	// +kubebuilder:validation:Optional
	AccessTokenLifespanForImplicitFlow *string `json:"accessTokenLifespanForImplicitFlow,omitempty" tf:"access_token_lifespan_for_implicit_flow,omitempty"`

	// Used for account management pages.
	// +kubebuilder:validation:Optional
	AccountTheme *string `json:"accountTheme,omitempty" tf:"account_theme,omitempty"`

	// The maximum time a user has to use an admin-generated permit before it expires.
	// +kubebuilder:validation:Optional
	ActionTokenGeneratedByAdminLifespan *string `json:"actionTokenGeneratedByAdminLifespan,omitempty" tf:"action_token_generated_by_admin_lifespan,omitempty"`

	// The maximum time a user has to use a user-generated permit before it expires.
	// +kubebuilder:validation:Optional
	ActionTokenGeneratedByUserLifespan *string `json:"actionTokenGeneratedByUserLifespan,omitempty" tf:"action_token_generated_by_user_lifespan,omitempty"`

	// Used for the admin console.
	// +kubebuilder:validation:Optional
	AdminTheme *string `json:"adminTheme,omitempty" tf:"admin_theme,omitempty"`

	// A map of custom attributes to add to the realm.
	// +kubebuilder:validation:Optional
	// +mapType=granular
	Attributes map[string]*string `json:"attributes,omitempty" tf:"attributes,omitempty"`

	// The desired flow for browser authentication. Defaults to browser.
	// Which flow should be used for BrowserFlow
	// +kubebuilder:validation:Optional
	BrowserFlow *string `json:"browserFlow,omitempty" tf:"browser_flow,omitempty"`

	// The desired flow for client authentication. Defaults to clients.
	// Which flow should be used for ClientAuthenticationFlow
	// +kubebuilder:validation:Optional
	ClientAuthenticationFlow *string `json:"clientAuthenticationFlow,omitempty" tf:"client_authentication_flow,omitempty"`

	// The amount of time a session can be idle before it expires. Users can override it for individual clients.
	// +kubebuilder:validation:Optional
	ClientSessionIdleTimeout *string `json:"clientSessionIdleTimeout,omitempty" tf:"client_session_idle_timeout,omitempty"`

	// The maximum amount of time before a session expires regardless of activity. Users can override it for individual clients.
	// +kubebuilder:validation:Optional
	ClientSessionMaxLifespan *string `json:"clientSessionMaxLifespan,omitempty" tf:"client_session_max_lifespan,omitempty"`

	// A list of default default client scopes to be used for client definitions. Defaults to [] or keycloak's built-in default default client-scopes.
	// +kubebuilder:validation:Optional
	// +listType=set
	DefaultDefaultClientScopes []*string `json:"defaultDefaultClientScopes,omitempty" tf:"default_default_client_scopes,omitempty"`

	// A list of default optional client scopes to be used for client definitions. Defaults to [] or keycloak's built-in default optional client-scopes.
	// +kubebuilder:validation:Optional
	// +listType=set
	DefaultOptionalClientScopes []*string `json:"defaultOptionalClientScopes,omitempty" tf:"default_optional_client_scopes,omitempty"`

	// Default algorithm used to sign tokens for the realm.
	// +kubebuilder:validation:Optional
	DefaultSignatureAlgorithm *string `json:"defaultSignatureAlgorithm,omitempty" tf:"default_signature_algorithm,omitempty"`

	// The desired flow for direct access authentication. Defaults to direct grant.
	// Which flow should be used for DirectGrantFlow
	// +kubebuilder:validation:Optional
	DirectGrantFlow *string `json:"directGrantFlow,omitempty" tf:"direct_grant_flow,omitempty"`

	// The display name for the realm that is shown when logging in to the admin console.
	// +kubebuilder:validation:Optional
	DisplayName *string `json:"displayName,omitempty" tf:"display_name,omitempty"`

	// The display name for the realm that is rendered as HTML on the screen when logging in to the admin console.
	// +kubebuilder:validation:Optional
	DisplayNameHTML *string `json:"displayNameHtml,omitempty" tf:"display_name_html,omitempty"`

	// The desired flow for Docker authentication. Defaults to docker auth.
	// Which flow should be used for DockerAuthenticationFlow
	// +kubebuilder:validation:Optional
	DockerAuthenticationFlow *string `json:"dockerAuthenticationFlow,omitempty" tf:"docker_authentication_flow,omitempty"`

	// When true, multiple users will be allowed to have the same email address. This argument must be set to false if login_with_email_allowed is set to true.
	// +kubebuilder:validation:Optional
	DuplicateEmailsAllowed *bool `json:"duplicateEmailsAllowed,omitempty" tf:"duplicate_emails_allowed,omitempty"`

	// When true, the username field is editable.
	// +kubebuilder:validation:Optional
	EditUsernameAllowed *bool `json:"editUsernameAllowed,omitempty" tf:"edit_username_allowed,omitempty"`

	// Used for emails that are sent by Keycloak.
	// +kubebuilder:validation:Optional
	EmailTheme *string `json:"emailTheme,omitempty" tf:"email_theme,omitempty"`

	// When false, users and clients will not be able to access this realm. Defaults to true.
	// +kubebuilder:validation:Optional
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`

	// When specified, this will be used as the realm's internal ID within Keycloak. When not specified, the realm's internal ID will be set to the realm's name.
	// +kubebuilder:validation:Optional
	InternalID *string `json:"internalId,omitempty" tf:"internal_id,omitempty"`

	// +kubebuilder:validation:Optional
	Internationalization []InternationalizationParameters `json:"internationalization,omitempty" tf:"internationalization,omitempty"`

	// Used for the login, forgot password, and registration pages.
	// +kubebuilder:validation:Optional
	LoginTheme *string `json:"loginTheme,omitempty" tf:"login_theme,omitempty"`

	// When true, users may log in with their email address.
	// +kubebuilder:validation:Optional
	LoginWithEmailAllowed *bool `json:"loginWithEmailAllowed,omitempty" tf:"login_with_email_allowed,omitempty"`

	// The maximum amount of time a client has to finish the device code flow before it expires.
	// +kubebuilder:validation:Optional
	Oauth2DeviceCodeLifespan *string `json:"oauth2DeviceCodeLifespan,omitempty" tf:"oauth2_device_code_lifespan,omitempty"`

	// The minimum amount of time in seconds that the client should wait between polling requests to the token endpoint.
	// +kubebuilder:validation:Optional
	Oauth2DevicePollingInterval *float64 `json:"oauth2DevicePollingInterval,omitempty" tf:"oauth2_device_polling_interval,omitempty"`

	// The amount of time an offline session can be idle before it expires.
	// +kubebuilder:validation:Optional
	OfflineSessionIdleTimeout *string `json:"offlineSessionIdleTimeout,omitempty" tf:"offline_session_idle_timeout,omitempty"`

	// The maximum amount of time before an offline session expires regardless of activity.
	// +kubebuilder:validation:Optional
	OfflineSessionMaxLifespan *string `json:"offlineSessionMaxLifespan,omitempty" tf:"offline_session_max_lifespan,omitempty"`

	// Enable offline_session_max_lifespan.
	// +kubebuilder:validation:Optional
	OfflineSessionMaxLifespanEnabled *bool `json:"offlineSessionMaxLifespanEnabled,omitempty" tf:"offline_session_max_lifespan_enabled,omitempty"`

	// +kubebuilder:validation:Optional
	OtpPolicy []OtpPolicyParameters `json:"otpPolicy,omitempty" tf:"otp_policy,omitempty"`

	// The password policy for users within the realm.
	// String that represents the passwordPolicies that are in place. Each policy is separated with " and ". Supported policies can be found in the server-info providers page. example: "upperCase(1) and length(8) and forceExpiredPasswordChange(365) and notUsername(undefined)"
	// +kubebuilder:validation:Optional
	PasswordPolicy *string `json:"passwordPolicy,omitempty" tf:"password_policy,omitempty"`

	// The name of the realm. This is unique across Keycloak. This will also be used as the realm's internal ID within Keycloak.
	// +kubebuilder:validation:Optional
	Realm *string `json:"realm,omitempty" tf:"realm,omitempty"`

	// Maximum number of times a refresh token can be reused before they are revoked. If unspecified and 'revoke_refresh_token' is enabled the default value is 0 and refresh tokens can not be reused.
	// +kubebuilder:validation:Optional
	RefreshTokenMaxReuse *float64 `json:"refreshTokenMaxReuse,omitempty" tf:"refresh_token_max_reuse,omitempty"`

	// When true, user registration will be enabled, and a link for registration will be displayed on the login page.
	// +kubebuilder:validation:Optional
	RegistrationAllowed *bool `json:"registrationAllowed,omitempty" tf:"registration_allowed,omitempty"`

	// When true, the user's email will be used as their username during registration.
	// +kubebuilder:validation:Optional
	RegistrationEmailAsUsername *bool `json:"registrationEmailAsUsername,omitempty" tf:"registration_email_as_username,omitempty"`

	// The desired flow for user registration. Defaults to registration.
	// Which flow should be used for RegistrationFlow
	// +kubebuilder:validation:Optional
	RegistrationFlow *string `json:"registrationFlow,omitempty" tf:"registration_flow,omitempty"`

	// When true, a "remember me" checkbox will be displayed on the login page, and the user's session will not expire between browser restarts.
	// +kubebuilder:validation:Optional
	RememberMe *bool `json:"rememberMe,omitempty" tf:"remember_me,omitempty"`

	// The desired flow to use when a user attempts to reset their credentials. Defaults to reset credentials.
	// Which flow should be used for ResetCredentialsFlow
	// +kubebuilder:validation:Optional
	ResetCredentialsFlow *string `json:"resetCredentialsFlow,omitempty" tf:"reset_credentials_flow,omitempty"`

	// When true, a "forgot password" link will be displayed on the login page.
	// +kubebuilder:validation:Optional
	ResetPasswordAllowed *bool `json:"resetPasswordAllowed,omitempty" tf:"reset_password_allowed,omitempty"`

	// If enabled a refresh token can only be used number of times specified in 'refresh_token_max_reuse' before they are revoked. If unspecified, refresh tokens can be reused.
	// +kubebuilder:validation:Optional
	RevokeRefreshToken *bool `json:"revokeRefreshToken,omitempty" tf:"revoke_refresh_token,omitempty"`

	// +kubebuilder:validation:Optional
	SMTPServer []SMTPServerParameters `json:"smtpServer,omitempty" tf:"smtp_server,omitempty"`

	// Can be one of following values: 'none, 'external' or 'all'
	// SSL Required: Values can be 'none', 'external' or 'all'.
	// +kubebuilder:validation:Optional
	SSLRequired *string `json:"sslRequired,omitempty" tf:"ssl_required,omitempty"`

	// +kubebuilder:validation:Optional
	SecurityDefenses []SecurityDefensesParameters `json:"securityDefenses,omitempty" tf:"security_defenses,omitempty"`

	// The amount of time a session can be idle before it expires.
	// +kubebuilder:validation:Optional
	SsoSessionIdleTimeout *string `json:"ssoSessionIdleTimeout,omitempty" tf:"sso_session_idle_timeout,omitempty"`

	// Similar to sso_session_idle_timeout, but used when a user clicks "Remember Me". If not set, Keycloak will default to the value of sso_session_idle_timeout.
	// +kubebuilder:validation:Optional
	SsoSessionIdleTimeoutRememberMe *string `json:"ssoSessionIdleTimeoutRememberMe,omitempty" tf:"sso_session_idle_timeout_remember_me,omitempty"`

	// The maximum amount of time before a session expires regardless of activity.
	// +kubebuilder:validation:Optional
	SsoSessionMaxLifespan *string `json:"ssoSessionMaxLifespan,omitempty" tf:"sso_session_max_lifespan,omitempty"`

	// Similar to sso_session_max_lifespan, but used when a user clicks "Remember Me". If not set, Keycloak will default to the value of sso_session_max_lifespan.
	// +kubebuilder:validation:Optional
	SsoSessionMaxLifespanRememberMe *string `json:"ssoSessionMaxLifespanRememberMe,omitempty" tf:"sso_session_max_lifespan_remember_me,omitempty"`

	// When true, users are allowed to manage their own resources. Defaults to false.
	// +kubebuilder:validation:Optional
	UserManagedAccess *bool `json:"userManagedAccess,omitempty" tf:"user_managed_access,omitempty"`

	// When true, users are required to verify their email address after registration and after email address changes.
	// +kubebuilder:validation:Optional
	VerifyEmail *bool `json:"verifyEmail,omitempty" tf:"verify_email,omitempty"`

	// Configuration for WebAuthn Passwordless Policy authentication.
	// +kubebuilder:validation:Optional
	WebAuthnPasswordlessPolicy []WebAuthnPasswordlessPolicyParameters `json:"webAuthnPasswordlessPolicy,omitempty" tf:"web_authn_passwordless_policy,omitempty"`

	// Configuration for WebAuthn Policy authentication.
	// +kubebuilder:validation:Optional
	WebAuthnPolicy []WebAuthnPolicyParameters `json:"webAuthnPolicy,omitempty" tf:"web_authn_policy,omitempty"`
}

type SMTPServerInitParameters struct {

	// Enables authentication to the SMTP server.  This block supports the following arguments:
	Auth []AuthInitParameters `json:"auth,omitempty" tf:"auth,omitempty"`

	// The email address uses for bounces.
	EnvelopeFrom *string `json:"envelopeFrom,omitempty" tf:"envelope_from,omitempty"`

	// The email address for the sender.
	From *string `json:"from,omitempty" tf:"from,omitempty"`

	// The display name of the sender email address.
	FromDisplayName *string `json:"fromDisplayName,omitempty" tf:"from_display_name,omitempty"`

	// The host of the SMTP server.
	Host *string `json:"host,omitempty" tf:"host,omitempty"`

	// The port of the SMTP server (defaults to 25).
	Port *string `json:"port,omitempty" tf:"port,omitempty"`

	// The "reply to" email address.
	ReplyTo *string `json:"replyTo,omitempty" tf:"reply_to,omitempty"`

	// The display name of the "reply to" email address.
	ReplyToDisplayName *string `json:"replyToDisplayName,omitempty" tf:"reply_to_display_name,omitempty"`

	// When true, enables SSL. Defaults to false.
	SSL *bool `json:"ssl,omitempty" tf:"ssl,omitempty"`

	// When true, enables StartTLS. Defaults to false.
	Starttls *bool `json:"starttls,omitempty" tf:"starttls,omitempty"`
}

type SMTPServerObservation struct {

	// Enables authentication to the SMTP server.  This block supports the following arguments:
	Auth []AuthObservation `json:"auth,omitempty" tf:"auth,omitempty"`

	// The email address uses for bounces.
	EnvelopeFrom *string `json:"envelopeFrom,omitempty" tf:"envelope_from,omitempty"`

	// The email address for the sender.
	From *string `json:"from,omitempty" tf:"from,omitempty"`

	// The display name of the sender email address.
	FromDisplayName *string `json:"fromDisplayName,omitempty" tf:"from_display_name,omitempty"`

	// The host of the SMTP server.
	Host *string `json:"host,omitempty" tf:"host,omitempty"`

	// The port of the SMTP server (defaults to 25).
	Port *string `json:"port,omitempty" tf:"port,omitempty"`

	// The "reply to" email address.
	ReplyTo *string `json:"replyTo,omitempty" tf:"reply_to,omitempty"`

	// The display name of the "reply to" email address.
	ReplyToDisplayName *string `json:"replyToDisplayName,omitempty" tf:"reply_to_display_name,omitempty"`

	// When true, enables SSL. Defaults to false.
	SSL *bool `json:"ssl,omitempty" tf:"ssl,omitempty"`

	// When true, enables StartTLS. Defaults to false.
	Starttls *bool `json:"starttls,omitempty" tf:"starttls,omitempty"`
}

type SMTPServerParameters struct {

	// Enables authentication to the SMTP server.  This block supports the following arguments:
	// +kubebuilder:validation:Optional
	Auth []AuthParameters `json:"auth,omitempty" tf:"auth,omitempty"`

	// The email address uses for bounces.
	// +kubebuilder:validation:Optional
	EnvelopeFrom *string `json:"envelopeFrom,omitempty" tf:"envelope_from,omitempty"`

	// The email address for the sender.
	// +kubebuilder:validation:Optional
	From *string `json:"from" tf:"from,omitempty"`

	// The display name of the sender email address.
	// +kubebuilder:validation:Optional
	FromDisplayName *string `json:"fromDisplayName,omitempty" tf:"from_display_name,omitempty"`

	// The host of the SMTP server.
	// +kubebuilder:validation:Optional
	Host *string `json:"host" tf:"host,omitempty"`

	// The port of the SMTP server (defaults to 25).
	// +kubebuilder:validation:Optional
	Port *string `json:"port,omitempty" tf:"port,omitempty"`

	// The "reply to" email address.
	// +kubebuilder:validation:Optional
	ReplyTo *string `json:"replyTo,omitempty" tf:"reply_to,omitempty"`

	// The display name of the "reply to" email address.
	// +kubebuilder:validation:Optional
	ReplyToDisplayName *string `json:"replyToDisplayName,omitempty" tf:"reply_to_display_name,omitempty"`

	// When true, enables SSL. Defaults to false.
	// +kubebuilder:validation:Optional
	SSL *bool `json:"ssl,omitempty" tf:"ssl,omitempty"`

	// When true, enables StartTLS. Defaults to false.
	// +kubebuilder:validation:Optional
	Starttls *bool `json:"starttls,omitempty" tf:"starttls,omitempty"`
}

type SecurityDefensesInitParameters struct {
	BruteForceDetection []BruteForceDetectionInitParameters `json:"bruteForceDetection,omitempty" tf:"brute_force_detection,omitempty"`

	Headers []HeadersInitParameters `json:"headers,omitempty" tf:"headers,omitempty"`
}

type SecurityDefensesObservation struct {
	BruteForceDetection []BruteForceDetectionObservation `json:"bruteForceDetection,omitempty" tf:"brute_force_detection,omitempty"`

	Headers []HeadersObservation `json:"headers,omitempty" tf:"headers,omitempty"`
}

type SecurityDefensesParameters struct {

	// +kubebuilder:validation:Optional
	BruteForceDetection []BruteForceDetectionParameters `json:"bruteForceDetection,omitempty" tf:"brute_force_detection,omitempty"`

	// +kubebuilder:validation:Optional
	Headers []HeadersParameters `json:"headers,omitempty" tf:"headers,omitempty"`
}

type WebAuthnPasswordlessPolicyInitParameters struct {

	// A set of AAGUIDs for which an authenticator can be registered.
	// +listType=set
	AcceptableAaguids []*string `json:"acceptableAaguids,omitempty" tf:"acceptable_aaguids,omitempty"`

	// The preference of how to generate a WebAuthn attestation statement. Valid options are not specified, none, indirect, direct, or enterprise. Defaults to not specified.
	// Either none, indirect or direct
	AttestationConveyancePreference *string `json:"attestationConveyancePreference,omitempty" tf:"attestation_conveyance_preference,omitempty"`

	// The acceptable attachment pattern for the WebAuthn authenticator. Valid options are not specified, platform, or cross-platform. Defaults to not specified.
	// Either platform or cross-platform
	AuthenticatorAttachment *string `json:"authenticatorAttachment,omitempty" tf:"authenticator_attachment,omitempty"`

	// When true, Keycloak will avoid registering the authenticator for WebAuthn if it has already been registered. Defaults to false.
	AvoidSameAuthenticatorRegister *bool `json:"avoidSameAuthenticatorRegister,omitempty" tf:"avoid_same_authenticator_register,omitempty"`

	// The timeout value for creating a user's public key credential in seconds. When set to 0, this timeout option is not adapted. Defaults to 0.
	CreateTimeout *float64 `json:"createTimeout,omitempty" tf:"create_timeout,omitempty"`

	// A human readable server name for the WebAuthn Relying Party. Defaults to keycloak.
	RelyingPartyEntityName *string `json:"relyingPartyEntityName,omitempty" tf:"relying_party_entity_name,omitempty"`

	// The WebAuthn relying party ID.
	RelyingPartyID *string `json:"relyingPartyId,omitempty" tf:"relying_party_id,omitempty"`

	// Specifies whether or not a public key should be created to represent the resident key. Valid options are not specified, Yes, or No. Defaults to not specified.
	// Either Yes or No
	RequireResidentKey *string `json:"requireResidentKey,omitempty" tf:"require_resident_key,omitempty"`

	// A set of signature algorithms that should be used for the authentication assertion. Valid options at the time these docs were written are ES256, ES384, ES512, RS256, RS384, RS512, and RS1.
	// Keycloak lists ES256, ES384, ES512, RS256, RS384, RS512, RS1 at the time of writing
	// +listType=set
	SignatureAlgorithms []*string `json:"signatureAlgorithms,omitempty" tf:"signature_algorithms,omitempty"`

	// Specifies the policy for verifying a user logging in via WebAuthn. Valid options are not specified, required, preferred, or discouraged. Defaults to not specified.
	// Either required, preferred or discouraged
	UserVerificationRequirement *string `json:"userVerificationRequirement,omitempty" tf:"user_verification_requirement,omitempty"`
}

type WebAuthnPasswordlessPolicyObservation struct {

	// A set of AAGUIDs for which an authenticator can be registered.
	// +listType=set
	AcceptableAaguids []*string `json:"acceptableAaguids,omitempty" tf:"acceptable_aaguids,omitempty"`

	// The preference of how to generate a WebAuthn attestation statement. Valid options are not specified, none, indirect, direct, or enterprise. Defaults to not specified.
	// Either none, indirect or direct
	AttestationConveyancePreference *string `json:"attestationConveyancePreference,omitempty" tf:"attestation_conveyance_preference,omitempty"`

	// The acceptable attachment pattern for the WebAuthn authenticator. Valid options are not specified, platform, or cross-platform. Defaults to not specified.
	// Either platform or cross-platform
	AuthenticatorAttachment *string `json:"authenticatorAttachment,omitempty" tf:"authenticator_attachment,omitempty"`

	// When true, Keycloak will avoid registering the authenticator for WebAuthn if it has already been registered. Defaults to false.
	AvoidSameAuthenticatorRegister *bool `json:"avoidSameAuthenticatorRegister,omitempty" tf:"avoid_same_authenticator_register,omitempty"`

	// The timeout value for creating a user's public key credential in seconds. When set to 0, this timeout option is not adapted. Defaults to 0.
	CreateTimeout *float64 `json:"createTimeout,omitempty" tf:"create_timeout,omitempty"`

	// A human readable server name for the WebAuthn Relying Party. Defaults to keycloak.
	RelyingPartyEntityName *string `json:"relyingPartyEntityName,omitempty" tf:"relying_party_entity_name,omitempty"`

	// The WebAuthn relying party ID.
	RelyingPartyID *string `json:"relyingPartyId,omitempty" tf:"relying_party_id,omitempty"`

	// Specifies whether or not a public key should be created to represent the resident key. Valid options are not specified, Yes, or No. Defaults to not specified.
	// Either Yes or No
	RequireResidentKey *string `json:"requireResidentKey,omitempty" tf:"require_resident_key,omitempty"`

	// A set of signature algorithms that should be used for the authentication assertion. Valid options at the time these docs were written are ES256, ES384, ES512, RS256, RS384, RS512, and RS1.
	// Keycloak lists ES256, ES384, ES512, RS256, RS384, RS512, RS1 at the time of writing
	// +listType=set
	SignatureAlgorithms []*string `json:"signatureAlgorithms,omitempty" tf:"signature_algorithms,omitempty"`

	// Specifies the policy for verifying a user logging in via WebAuthn. Valid options are not specified, required, preferred, or discouraged. Defaults to not specified.
	// Either required, preferred or discouraged
	UserVerificationRequirement *string `json:"userVerificationRequirement,omitempty" tf:"user_verification_requirement,omitempty"`
}

type WebAuthnPasswordlessPolicyParameters struct {

	// A set of AAGUIDs for which an authenticator can be registered.
	// +kubebuilder:validation:Optional
	// +listType=set
	AcceptableAaguids []*string `json:"acceptableAaguids,omitempty" tf:"acceptable_aaguids,omitempty"`

	// The preference of how to generate a WebAuthn attestation statement. Valid options are not specified, none, indirect, direct, or enterprise. Defaults to not specified.
	// Either none, indirect or direct
	// +kubebuilder:validation:Optional
	AttestationConveyancePreference *string `json:"attestationConveyancePreference,omitempty" tf:"attestation_conveyance_preference,omitempty"`

	// The acceptable attachment pattern for the WebAuthn authenticator. Valid options are not specified, platform, or cross-platform. Defaults to not specified.
	// Either platform or cross-platform
	// +kubebuilder:validation:Optional
	AuthenticatorAttachment *string `json:"authenticatorAttachment,omitempty" tf:"authenticator_attachment,omitempty"`

	// When true, Keycloak will avoid registering the authenticator for WebAuthn if it has already been registered. Defaults to false.
	// +kubebuilder:validation:Optional
	AvoidSameAuthenticatorRegister *bool `json:"avoidSameAuthenticatorRegister,omitempty" tf:"avoid_same_authenticator_register,omitempty"`

	// The timeout value for creating a user's public key credential in seconds. When set to 0, this timeout option is not adapted. Defaults to 0.
	// +kubebuilder:validation:Optional
	CreateTimeout *float64 `json:"createTimeout,omitempty" tf:"create_timeout,omitempty"`

	// A human readable server name for the WebAuthn Relying Party. Defaults to keycloak.
	// +kubebuilder:validation:Optional
	RelyingPartyEntityName *string `json:"relyingPartyEntityName,omitempty" tf:"relying_party_entity_name,omitempty"`

	// The WebAuthn relying party ID.
	// +kubebuilder:validation:Optional
	RelyingPartyID *string `json:"relyingPartyId,omitempty" tf:"relying_party_id,omitempty"`

	// Specifies whether or not a public key should be created to represent the resident key. Valid options are not specified, Yes, or No. Defaults to not specified.
	// Either Yes or No
	// +kubebuilder:validation:Optional
	RequireResidentKey *string `json:"requireResidentKey,omitempty" tf:"require_resident_key,omitempty"`

	// A set of signature algorithms that should be used for the authentication assertion. Valid options at the time these docs were written are ES256, ES384, ES512, RS256, RS384, RS512, and RS1.
	// Keycloak lists ES256, ES384, ES512, RS256, RS384, RS512, RS1 at the time of writing
	// +kubebuilder:validation:Optional
	// +listType=set
	SignatureAlgorithms []*string `json:"signatureAlgorithms,omitempty" tf:"signature_algorithms,omitempty"`

	// Specifies the policy for verifying a user logging in via WebAuthn. Valid options are not specified, required, preferred, or discouraged. Defaults to not specified.
	// Either required, preferred or discouraged
	// +kubebuilder:validation:Optional
	UserVerificationRequirement *string `json:"userVerificationRequirement,omitempty" tf:"user_verification_requirement,omitempty"`
}

type WebAuthnPolicyInitParameters struct {

	// A set of AAGUIDs for which an authenticator can be registered.
	// +listType=set
	AcceptableAaguids []*string `json:"acceptableAaguids,omitempty" tf:"acceptable_aaguids,omitempty"`

	// The preference of how to generate a WebAuthn attestation statement. Valid options are not specified, none, indirect, direct, or enterprise. Defaults to not specified.
	// Either none, indirect or direct
	AttestationConveyancePreference *string `json:"attestationConveyancePreference,omitempty" tf:"attestation_conveyance_preference,omitempty"`

	// The acceptable attachment pattern for the WebAuthn authenticator. Valid options are not specified, platform, or cross-platform. Defaults to not specified.
	// Either platform or cross-platform
	AuthenticatorAttachment *string `json:"authenticatorAttachment,omitempty" tf:"authenticator_attachment,omitempty"`

	// When true, Keycloak will avoid registering the authenticator for WebAuthn if it has already been registered. Defaults to false.
	AvoidSameAuthenticatorRegister *bool `json:"avoidSameAuthenticatorRegister,omitempty" tf:"avoid_same_authenticator_register,omitempty"`

	// The timeout value for creating a user's public key credential in seconds. When set to 0, this timeout option is not adapted. Defaults to 0.
	CreateTimeout *float64 `json:"createTimeout,omitempty" tf:"create_timeout,omitempty"`

	// A human readable server name for the WebAuthn Relying Party. Defaults to keycloak.
	RelyingPartyEntityName *string `json:"relyingPartyEntityName,omitempty" tf:"relying_party_entity_name,omitempty"`

	// The WebAuthn relying party ID.
	RelyingPartyID *string `json:"relyingPartyId,omitempty" tf:"relying_party_id,omitempty"`

	// Specifies whether or not a public key should be created to represent the resident key. Valid options are not specified, Yes, or No. Defaults to not specified.
	// Either Yes or No
	RequireResidentKey *string `json:"requireResidentKey,omitempty" tf:"require_resident_key,omitempty"`

	// A set of signature algorithms that should be used for the authentication assertion. Valid options at the time these docs were written are ES256, ES384, ES512, RS256, RS384, RS512, and RS1.
	// Keycloak lists ES256, ES384, ES512, RS256, RS384, RS512, RS1 at the time of writing
	// +listType=set
	SignatureAlgorithms []*string `json:"signatureAlgorithms,omitempty" tf:"signature_algorithms,omitempty"`

	// Specifies the policy for verifying a user logging in via WebAuthn. Valid options are not specified, required, preferred, or discouraged. Defaults to not specified.
	// Either required, preferred or discouraged
	UserVerificationRequirement *string `json:"userVerificationRequirement,omitempty" tf:"user_verification_requirement,omitempty"`
}

type WebAuthnPolicyObservation struct {

	// A set of AAGUIDs for which an authenticator can be registered.
	// +listType=set
	AcceptableAaguids []*string `json:"acceptableAaguids,omitempty" tf:"acceptable_aaguids,omitempty"`

	// The preference of how to generate a WebAuthn attestation statement. Valid options are not specified, none, indirect, direct, or enterprise. Defaults to not specified.
	// Either none, indirect or direct
	AttestationConveyancePreference *string `json:"attestationConveyancePreference,omitempty" tf:"attestation_conveyance_preference,omitempty"`

	// The acceptable attachment pattern for the WebAuthn authenticator. Valid options are not specified, platform, or cross-platform. Defaults to not specified.
	// Either platform or cross-platform
	AuthenticatorAttachment *string `json:"authenticatorAttachment,omitempty" tf:"authenticator_attachment,omitempty"`

	// When true, Keycloak will avoid registering the authenticator for WebAuthn if it has already been registered. Defaults to false.
	AvoidSameAuthenticatorRegister *bool `json:"avoidSameAuthenticatorRegister,omitempty" tf:"avoid_same_authenticator_register,omitempty"`

	// The timeout value for creating a user's public key credential in seconds. When set to 0, this timeout option is not adapted. Defaults to 0.
	CreateTimeout *float64 `json:"createTimeout,omitempty" tf:"create_timeout,omitempty"`

	// A human readable server name for the WebAuthn Relying Party. Defaults to keycloak.
	RelyingPartyEntityName *string `json:"relyingPartyEntityName,omitempty" tf:"relying_party_entity_name,omitempty"`

	// The WebAuthn relying party ID.
	RelyingPartyID *string `json:"relyingPartyId,omitempty" tf:"relying_party_id,omitempty"`

	// Specifies whether or not a public key should be created to represent the resident key. Valid options are not specified, Yes, or No. Defaults to not specified.
	// Either Yes or No
	RequireResidentKey *string `json:"requireResidentKey,omitempty" tf:"require_resident_key,omitempty"`

	// A set of signature algorithms that should be used for the authentication assertion. Valid options at the time these docs were written are ES256, ES384, ES512, RS256, RS384, RS512, and RS1.
	// Keycloak lists ES256, ES384, ES512, RS256, RS384, RS512, RS1 at the time of writing
	// +listType=set
	SignatureAlgorithms []*string `json:"signatureAlgorithms,omitempty" tf:"signature_algorithms,omitempty"`

	// Specifies the policy for verifying a user logging in via WebAuthn. Valid options are not specified, required, preferred, or discouraged. Defaults to not specified.
	// Either required, preferred or discouraged
	UserVerificationRequirement *string `json:"userVerificationRequirement,omitempty" tf:"user_verification_requirement,omitempty"`
}

type WebAuthnPolicyParameters struct {

	// A set of AAGUIDs for which an authenticator can be registered.
	// +kubebuilder:validation:Optional
	// +listType=set
	AcceptableAaguids []*string `json:"acceptableAaguids,omitempty" tf:"acceptable_aaguids,omitempty"`

	// The preference of how to generate a WebAuthn attestation statement. Valid options are not specified, none, indirect, direct, or enterprise. Defaults to not specified.
	// Either none, indirect or direct
	// +kubebuilder:validation:Optional
	AttestationConveyancePreference *string `json:"attestationConveyancePreference,omitempty" tf:"attestation_conveyance_preference,omitempty"`

	// The acceptable attachment pattern for the WebAuthn authenticator. Valid options are not specified, platform, or cross-platform. Defaults to not specified.
	// Either platform or cross-platform
	// +kubebuilder:validation:Optional
	AuthenticatorAttachment *string `json:"authenticatorAttachment,omitempty" tf:"authenticator_attachment,omitempty"`

	// When true, Keycloak will avoid registering the authenticator for WebAuthn if it has already been registered. Defaults to false.
	// +kubebuilder:validation:Optional
	AvoidSameAuthenticatorRegister *bool `json:"avoidSameAuthenticatorRegister,omitempty" tf:"avoid_same_authenticator_register,omitempty"`

	// The timeout value for creating a user's public key credential in seconds. When set to 0, this timeout option is not adapted. Defaults to 0.
	// +kubebuilder:validation:Optional
	CreateTimeout *float64 `json:"createTimeout,omitempty" tf:"create_timeout,omitempty"`

	// A human readable server name for the WebAuthn Relying Party. Defaults to keycloak.
	// +kubebuilder:validation:Optional
	RelyingPartyEntityName *string `json:"relyingPartyEntityName,omitempty" tf:"relying_party_entity_name,omitempty"`

	// The WebAuthn relying party ID.
	// +kubebuilder:validation:Optional
	RelyingPartyID *string `json:"relyingPartyId,omitempty" tf:"relying_party_id,omitempty"`

	// Specifies whether or not a public key should be created to represent the resident key. Valid options are not specified, Yes, or No. Defaults to not specified.
	// Either Yes or No
	// +kubebuilder:validation:Optional
	RequireResidentKey *string `json:"requireResidentKey,omitempty" tf:"require_resident_key,omitempty"`

	// A set of signature algorithms that should be used for the authentication assertion. Valid options at the time these docs were written are ES256, ES384, ES512, RS256, RS384, RS512, and RS1.
	// Keycloak lists ES256, ES384, ES512, RS256, RS384, RS512, RS1 at the time of writing
	// +kubebuilder:validation:Optional
	// +listType=set
	SignatureAlgorithms []*string `json:"signatureAlgorithms,omitempty" tf:"signature_algorithms,omitempty"`

	// Specifies the policy for verifying a user logging in via WebAuthn. Valid options are not specified, required, preferred, or discouraged. Defaults to not specified.
	// Either required, preferred or discouraged
	// +kubebuilder:validation:Optional
	UserVerificationRequirement *string `json:"userVerificationRequirement,omitempty" tf:"user_verification_requirement,omitempty"`
}

// RealmSpec defines the desired state of Realm
type RealmSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     RealmParameters `json:"forProvider"`
	// THIS IS A BETA FIELD. It will be honored
	// unless the Management Policies feature flag is disabled.
	// InitProvider holds the same fields as ForProvider, with the exception
	// of Identifier and other resource reference fields. The fields that are
	// in InitProvider are merged into ForProvider when the resource is created.
	// The same fields are also added to the terraform ignore_changes hook, to
	// avoid updating them after creation. This is useful for fields that are
	// required on creation, but we do not desire to update them after creation,
	// for example because of an external controller is managing them, like an
	// autoscaler.
	InitProvider RealmInitParameters `json:"initProvider,omitempty"`
}

// RealmStatus defines the observed state of Realm.
type RealmStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        RealmObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status

// Realm is the Schema for the Realms API.
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,keycloak}
type Realm struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.realm) || (has(self.initProvider) && has(self.initProvider.realm))",message="spec.forProvider.realm is a required parameter"
	Spec   RealmSpec   `json:"spec"`
	Status RealmStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// RealmList contains a list of Realms
type RealmList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Realm `json:"items"`
}

// Repository type metadata.
var (
	Realm_Kind             = "Realm"
	Realm_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: Realm_Kind}.String()
	Realm_KindAPIVersion   = Realm_Kind + "." + CRDGroupVersion.String()
	Realm_GroupVersionKind = CRDGroupVersion.WithKind(Realm_Kind)
)

func init() {
	SchemeBuilder.Register(&Realm{}, &RealmList{})
}
