/*
Copyright 2022 Upbound Inc.
*/

// Code generated by upjet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type AuthenticationFlowBindingOverridesObservation struct {
}

type AuthenticationFlowBindingOverridesParameters struct {

	// +kubebuilder:validation:Optional
	BrowserID *string `json:"browserId,omitempty" tf:"browser_id,omitempty"`

	// +kubebuilder:validation:Optional
	DirectGrantID *string `json:"directGrantId,omitempty" tf:"direct_grant_id,omitempty"`
}

type AuthorizationObservation struct {
}

type AuthorizationParameters struct {

	// +kubebuilder:validation:Optional
	AllowRemoteResourceManagement *bool `json:"allowRemoteResourceManagement,omitempty" tf:"allow_remote_resource_management,omitempty"`

	// +kubebuilder:validation:Optional
	DecisionStrategy *string `json:"decisionStrategy,omitempty" tf:"decision_strategy,omitempty"`

	// +kubebuilder:validation:Optional
	KeepDefaults *bool `json:"keepDefaults,omitempty" tf:"keep_defaults,omitempty"`

	// +kubebuilder:validation:Required
	PolicyEnforcementMode *string `json:"policyEnforcementMode" tf:"policy_enforcement_mode,omitempty"`
}

type ClientObservation struct {
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	ResourceServerID *string `json:"resourceServerId,omitempty" tf:"resource_server_id,omitempty"`

	ServiceAccountUserID *string `json:"serviceAccountUserId,omitempty" tf:"service_account_user_id,omitempty"`
}

type ClientParameters struct {

	// +kubebuilder:validation:Optional
	AccessTokenLifespan *string `json:"accessTokenLifespan,omitempty" tf:"access_token_lifespan,omitempty"`

	// +kubebuilder:validation:Required
	AccessType *string `json:"accessType" tf:"access_type,omitempty"`

	// +kubebuilder:validation:Optional
	AdminURL *string `json:"adminUrl,omitempty" tf:"admin_url,omitempty"`

	// +kubebuilder:validation:Optional
	AuthenticationFlowBindingOverrides []AuthenticationFlowBindingOverridesParameters `json:"authenticationFlowBindingOverrides,omitempty" tf:"authentication_flow_binding_overrides,omitempty"`

	// +kubebuilder:validation:Optional
	Authorization []AuthorizationParameters `json:"authorization,omitempty" tf:"authorization,omitempty"`

	// +kubebuilder:validation:Optional
	BackchannelLogoutRevokeOfflineSessions *bool `json:"backchannelLogoutRevokeOfflineSessions,omitempty" tf:"backchannel_logout_revoke_offline_sessions,omitempty"`

	// +kubebuilder:validation:Optional
	BackchannelLogoutSessionRequired *bool `json:"backchannelLogoutSessionRequired,omitempty" tf:"backchannel_logout_session_required,omitempty"`

	// +kubebuilder:validation:Optional
	BackchannelLogoutURL *string `json:"backchannelLogoutUrl,omitempty" tf:"backchannel_logout_url,omitempty"`

	// +kubebuilder:validation:Optional
	BaseURL *string `json:"baseUrl,omitempty" tf:"base_url,omitempty"`

	// +kubebuilder:validation:Optional
	ClientAuthenticatorType *string `json:"clientAuthenticatorType,omitempty" tf:"client_authenticator_type,omitempty"`

	// +kubebuilder:validation:Required
	ClientID *string `json:"clientId" tf:"client_id,omitempty"`

	// +kubebuilder:validation:Optional
	ClientOfflineSessionIdleTimeout *string `json:"clientOfflineSessionIdleTimeout,omitempty" tf:"client_offline_session_idle_timeout,omitempty"`

	// +kubebuilder:validation:Optional
	ClientOfflineSessionMaxLifespan *string `json:"clientOfflineSessionMaxLifespan,omitempty" tf:"client_offline_session_max_lifespan,omitempty"`

	// +kubebuilder:validation:Optional
	ClientSecretSecretRef *v1.SecretKeySelector `json:"clientSecretSecretRef,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	ClientSessionIdleTimeout *string `json:"clientSessionIdleTimeout,omitempty" tf:"client_session_idle_timeout,omitempty"`

	// +kubebuilder:validation:Optional
	ClientSessionMaxLifespan *string `json:"clientSessionMaxLifespan,omitempty" tf:"client_session_max_lifespan,omitempty"`

	// +kubebuilder:validation:Optional
	ConsentRequired *bool `json:"consentRequired,omitempty" tf:"consent_required,omitempty"`

	// +kubebuilder:validation:Optional
	ConsentScreenText *string `json:"consentScreenText,omitempty" tf:"consent_screen_text,omitempty"`

	// +kubebuilder:validation:Optional
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// +kubebuilder:validation:Optional
	DirectAccessGrantsEnabled *bool `json:"directAccessGrantsEnabled,omitempty" tf:"direct_access_grants_enabled,omitempty"`

	// +kubebuilder:validation:Optional
	DisplayOnConsentScreen *bool `json:"displayOnConsentScreen,omitempty" tf:"display_on_consent_screen,omitempty"`

	// +kubebuilder:validation:Optional
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`

	// +kubebuilder:validation:Optional
	ExcludeSessionStateFromAuthResponse *bool `json:"excludeSessionStateFromAuthResponse,omitempty" tf:"exclude_session_state_from_auth_response,omitempty"`

	// +kubebuilder:validation:Optional
	ExtraConfig map[string]*string `json:"extraConfig,omitempty" tf:"extra_config,omitempty"`

	// +kubebuilder:validation:Optional
	FrontchannelLogoutEnabled *bool `json:"frontchannelLogoutEnabled,omitempty" tf:"frontchannel_logout_enabled,omitempty"`

	// +kubebuilder:validation:Optional
	FrontchannelLogoutURL *string `json:"frontchannelLogoutUrl,omitempty" tf:"frontchannel_logout_url,omitempty"`

	// +kubebuilder:validation:Optional
	FullScopeAllowed *bool `json:"fullScopeAllowed,omitempty" tf:"full_scope_allowed,omitempty"`

	// +kubebuilder:validation:Optional
	ImplicitFlowEnabled *bool `json:"implicitFlowEnabled,omitempty" tf:"implicit_flow_enabled,omitempty"`

	// +kubebuilder:validation:Optional
	Import *bool `json:"import,omitempty" tf:"import,omitempty"`

	// +kubebuilder:validation:Optional
	LoginTheme *string `json:"loginTheme,omitempty" tf:"login_theme,omitempty"`

	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// +kubebuilder:validation:Optional
	Oauth2DeviceAuthorizationGrantEnabled *bool `json:"oauth2DeviceAuthorizationGrantEnabled,omitempty" tf:"oauth2_device_authorization_grant_enabled,omitempty"`

	// +kubebuilder:validation:Optional
	Oauth2DeviceCodeLifespan *string `json:"oauth2DeviceCodeLifespan,omitempty" tf:"oauth2_device_code_lifespan,omitempty"`

	// +kubebuilder:validation:Optional
	Oauth2DevicePollingInterval *string `json:"oauth2DevicePollingInterval,omitempty" tf:"oauth2_device_polling_interval,omitempty"`

	// +kubebuilder:validation:Optional
	PkceCodeChallengeMethod *string `json:"pkceCodeChallengeMethod,omitempty" tf:"pkce_code_challenge_method,omitempty"`

	// +kubebuilder:validation:Required
	RealmID *string `json:"realmId" tf:"realm_id,omitempty"`

	// +kubebuilder:validation:Optional
	RootURL *string `json:"rootUrl,omitempty" tf:"root_url,omitempty"`

	// +kubebuilder:validation:Optional
	ServiceAccountsEnabled *bool `json:"serviceAccountsEnabled,omitempty" tf:"service_accounts_enabled,omitempty"`

	// +kubebuilder:validation:Optional
	StandardFlowEnabled *bool `json:"standardFlowEnabled,omitempty" tf:"standard_flow_enabled,omitempty"`

	// +kubebuilder:validation:Optional
	UseRefreshTokens *bool `json:"useRefreshTokens,omitempty" tf:"use_refresh_tokens,omitempty"`

	// +kubebuilder:validation:Optional
	UseRefreshTokensClientCredentials *bool `json:"useRefreshTokensClientCredentials,omitempty" tf:"use_refresh_tokens_client_credentials,omitempty"`

	// +kubebuilder:validation:Optional
	ValidPostLogoutRedirectUris []*string `json:"validPostLogoutRedirectUris,omitempty" tf:"valid_post_logout_redirect_uris,omitempty"`

	// +kubebuilder:validation:Optional
	ValidRedirectUris []*string `json:"validRedirectUris,omitempty" tf:"valid_redirect_uris,omitempty"`

	// +kubebuilder:validation:Optional
	WebOrigins []*string `json:"webOrigins,omitempty" tf:"web_origins,omitempty"`
}

// ClientSpec defines the desired state of Client
type ClientSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     ClientParameters `json:"forProvider"`
}

// ClientStatus defines the observed state of Client.
type ClientStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        ClientObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// Client is the Schema for the Clients API. <no value>
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,keycloak}
type Client struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              ClientSpec   `json:"spec"`
	Status            ClientStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// ClientList contains a list of Clients
type ClientList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Client `json:"items"`
}

// Repository type metadata.
var (
	Client_Kind             = "Client"
	Client_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: Client_Kind}.String()
	Client_KindAPIVersion   = Client_Kind + "." + CRDGroupVersion.String()
	Client_GroupVersionKind = CRDGroupVersion.WithKind(Client_Kind)
)

func init() {
	SchemeBuilder.Register(&Client{}, &ClientList{})
}
